Directory Structure:

└── ./
    └── packages
        └── core
            ├── src
            │   ├── components
            │   │   ├── auth
            │   │   │   ├── can.tsx
            │   │   │   └── index.ts
            │   │   ├── common
            │   │   │   ├── icon.tsx
            │   │   │   ├── index.ts
            │   │   │   └── logo.tsx
            │   │   ├── loader
            │   │   │   ├── remote
            │   │   │   │   ├── index.ts
            │   │   │   │   ├── loader.tsx
            │   │   │   │   └── render.tsx
            │   │   │   ├── iframe.tsx
            │   │   │   ├── index.ts
            │   │   │   └── loader.tsx
            │   │   ├── overlay
            │   │   │   ├── index.ts
            │   │   │   └── overlay.tsx
            │   │   ├── status
            │   │   │   ├── error.tsx
            │   │   │   ├── exception.tsx
            │   │   │   ├── index.ts
            │   │   │   ├── notAuthorized.tsx
            │   │   │   └── notFound.tsx
            │   │   └── index.ts
            │   ├── config
            │   │   ├── color.ts
            │   │   └── index.ts
            │   ├── directive
            │   │   ├── index.ts
            │   │   └── permission.ts
            │   ├── hooks
            │   │   ├── json
            │   │   │   ├── utils
            │   │   │   │   ├── contextManager.ts
            │   │   │   │   └── expressionParser.ts
            │   │   │   ├── index.ts
            │   │   │   ├── types.ts
            │   │   │   ├── vFor.ts
            │   │   │   ├── vIf.ts
            │   │   │   ├── vModel.ts
            │   │   │   ├── vOn.ts
            │   │   │   ├── vShow.ts
            │   │   │   └── vText.ts
            │   │   ├── upload
            │   │   │   ├── index.ts
            │   │   │   ├── local.ts
            │   │   │   ├── s3.ts
            │   │   │   └── types.ts
            │   │   ├── auth.ts
            │   │   ├── config.ts
            │   │   ├── data.ts
            │   │   ├── export.ts
            │   │   ├── exportCsv.ts
            │   │   ├── form.ts
            │   │   ├── formExtend.ts
            │   │   ├── formValidate.ts
            │   │   ├── i18n.ts
            │   │   ├── import.ts
            │   │   ├── importCsv.ts
            │   │   ├── index.ts
            │   │   ├── json.tsx
            │   │   ├── list.tsx
            │   │   ├── manage.ts
            │   │   ├── menu.ts
            │   │   ├── overlay.ts
            │   │   ├── select.ts
            │   │   ├── theme.ts
            │   │   ├── tree.ts
            │   │   └── upload.ts
            │   ├── preset
            │   │   ├── authProvider.ts
            │   │   ├── dataProvider.ts
            │   │   ├── i18nProvider.ts
            │   │   └── index.ts
            │   ├── provider
            │   │   ├── app.tsx
            │   │   ├── index.ts
            │   │   └── tab.tsx
            │   ├── router
            │   │   ├── index.ts
            │   │   └── route.ts
            │   ├── stores
            │   │   ├── auth.ts
            │   │   ├── i18n.ts
            │   │   ├── index.ts
            │   │   ├── jsonSchema.ts
            │   │   ├── manage.ts
            │   │   ├── route.ts
            │   │   ├── tab.ts
            │   │   └── theme.ts
            │   ├── types
            │   │   ├── auth.ts
            │   │   ├── config.ts
            │   │   ├── data.ts
            │   │   ├── i18n.ts
            │   │   ├── index.ts
            │   │   ├── manage.ts
            │   │   ├── menu.ts
            │   │   └── theme.ts
            │   ├── utils
            │   │   ├── bus.ts
            │   │   ├── index.ts
            │   │   ├── theme.ts
            │   │   └── tree.ts
            │   ├── index.ts
            │   └── main.ts
            ├── .gitignore
            ├── CHANGELOG.md
            ├── LICENSE
            ├── package.json
            ├── README.md
            ├── tsconfig.json
            ├── typings.d.ts
            └── vite.config.ts



---
File: /packages/core/src/components/auth/can.tsx
---

import type { PropType } from 'vue'
import { defineComponent } from 'vue'
import { useCan } from '../../hooks'

export const DuxCan = defineComponent({
  name: 'DuxCan',
  props: {
    name: { type: String, required: true },
    params: { type: Object as PropType<any> },
  },
  setup(props, { slots }) {
    const can = useCan()
    return () => can(props.name, props.params) ? slots.default?.() : (slots.fallback?.() || null)
  },
})



---
File: /packages/core/src/components/auth/index.ts
---

export * from './can'



---
File: /packages/core/src/components/common/icon.tsx
---

import clsx from 'clsx'
import { defineComponent } from 'vue'

export const DuxLogoIcon = defineComponent({
  name: 'DuxLogoIcon',
  props: {
    highlight: { type: String, default: 'fill-primary' },
  },
  setup(props) {
    return () => (
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 202.97 197.7"
        class={clsx([
          props.highlight,
        ])}
      >
        <path d="M170,94.52l-35.9-20.73-24.34,14,11.62,6.71a5,5,0,0,1,0,8.66L32.5,154.52a5,5,0,0,1-7.5-4.33V99.61a6.44,6.44,0,0,1,0-1.52V47.51a5,5,0,0,1,7.5-4.33l35,20.23,24.32-14L7.5.68A5,5,0,0,0,0,5V192.69A5,5,0,0,0,7.5,197L170,103.18A5,5,0,0,0,170,94.52Z" />
        <path d="M32.93,103.18l35.9,20.73,24.34-14-11.62-6.71a5,5,0,0,1,0-8.66l88.92-51.34a5,5,0,0,1,7.5,4.33V98.09a6.44,6.44,0,0,1,0,1.52v50.58a5,5,0,0,1-7.5,4.33l-35-20.23-24.32,14L195.47,197a5,5,0,0,0,7.5-4.33V5a5,5,0,0,0-7.5-4.33L32.93,94.52A5,5,0,0,0,32.93,103.18Z" />
      </svg>
    )
  },
})



---
File: /packages/core/src/components/common/index.ts
---

export * from './logo'
export * from './icon'



---
File: /packages/core/src/components/common/logo.tsx
---

import clsx from 'clsx'
import { defineComponent } from 'vue'

export const DuxLogo = defineComponent({
  name: 'DuxLogo',
  props: {
    dark: { type: Boolean, default: false },
    highlight: { type: String, default: 'fill-primary' },
  },
  setup(props) {
    return () => (
      <svg
        class="w-auto h-full"
        viewBox="0 0 400.893 121.787"
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
      >
        <g
          transform="translate(-6545.000000, -3038.106602) translate(6345.000000, 2899.000000) translate(200.000000, 132.393398)"
          fill-rule="nonzero"
          stroke="none"
          stroke-width="1"
          fill="none"
        >
          <path
            d="M0 62.607v50c0 8.284 6.716 15 15 15s15-6.716 15-15v-50c0-8.285-6.716-15-15-15s-15 6.715-15 15z"
            class={clsx([
              props.dark ? 'fill-white/90' : 'fill-black dark:fill-white/90',
            ])}
          />
          <path
            d="M60 7.607c33.137 0 60 26.863 60 60s-26.863 60-60 60h-5c-8.284 0-15-6.716-15-15 0-8.285 6.716-15 15-15h5c16.57 0 30-13.432 30-30 0-16.57-13.43-30-30-30H15c-8.284 0-15-6.716-15-15 0-8.285 6.716-15 15-15h45z"
            class={clsx([
              props.dark ? 'fill-white/90' : 'fill-black dark:fill-white/90',
            ])}
          />
          <path
            d="M201 7.607c33.137 0 60 26.863 60 60s-26.863 60-60 60h-46c-8.284 0-15-6.716-15-15 0-8.285 6.716-15 15-15h46c16.57 0 30-13.432 30-30 0-16.57-13.43-30-30-30h-45.5c-8.284 0-15-6.716-15-15 0-8.285 6.716-15 15-15H201z"
            class={clsx([
              props.dark ? 'fill-white/90' : 'fill-black dark:fill-white/90',
            ])}
            transform="translate(200.500000, 67.606602) rotate(90.000000) translate(-200.500000, -67.606602) "
          />
          <g transform="translate(279.106602, 6.713203)">
            <path
              d="M25.607 4.393 52.893 31.68c5.858 5.858 5.858 15.356 0 21.213-5.857 5.858-15.355 5.858-21.213 0L4.393 25.607c-5.857-5.858-5.857-15.356 0-21.214 5.858-5.857 15.356-5.857 21.214 0zm91.786 0c5.858 5.858 5.858 15.356 0 21.214L90.107 52.893c-5.858 5.858-15.356 5.858-21.214 0-5.857-5.857-5.857-15.355 0-21.213L96.18 4.393c5.858-5.857 15.356-5.857 21.213 0zm-64.5 64.5c5.858 5.858 5.858 15.356 0 21.214l-27.286 27.286c-5.858 5.858-15.356 5.858-21.214 0-5.857-5.857-5.857-15.355 0-21.213L31.68 68.893c5.858-5.857 15.356-5.857 21.213 0z"
              class={clsx([
                props.dark ? 'fill-white/90' : 'fill-black dark:fill-white/90',
              ])}
            />
            <path
              d="m90.107 68.893 27.286 27.287c5.858 5.858 5.858 15.356 0 21.213-5.857 5.858-15.355 5.858-21.213 0L68.893 90.107c-5.857-5.858-5.857-15.356 0-21.214 5.858-5.857 15.356-5.857 21.214 0z"
              class={clsx([
                props.highlight,
              ])}
            />
          </g>
        </g>
      </svg>
    )
  },
})



---
File: /packages/core/src/components/loader/remote/index.ts
---

export * from './loader'
export * from './render'



---
File: /packages/core/src/components/loader/remote/loader.tsx
---

import type { Options, Resource } from 'vue3-sfc-loader'
import * as vueQuery from '@tanstack/vue-query'
import * as vueUse from '@vueuse/core'
import axios from 'axios'
import crypto from 'crypto-js'
import dayjs from 'dayjs'
import * as _ from 'lodash-es'
import * as math from 'mathjs'
import mime from 'mime'
import mitt from 'mitt'
import * as pinia from 'pinia'
import * as Vue from 'vue'
import { loadModule } from 'vue3-sfc-loader'
import * as vueRouter from 'vue-router'
import { useManage } from '../../../hooks'
import * as index from '../../../index'

const styleCache = new Map<string, boolean>()

function hashString(str: string): string {
  return crypto.MD5(str).toString().substring(0, 10)
}

export function sfcLoader(path: string) {
  const client = index.useClient()

  const { mergeLocale } = index.useI18n()

  const { config } = useManage()

  const options: Options = {
    moduleCache: {
      'vue': Vue,
      '@duxweb/dvha-core': index,
      '@vueuse/core': vueUse,
      '@tanstack/vue-query': vueQuery,
      'axios': axios,
      'crypto': crypto,
      'mime': mime,
      'math': math,
      'mitt': mitt,
      'lodash-es': _,
      'pinia': pinia,
      'dayjs': dayjs,
      'vue-router': vueRouter,
      ...config?.remote?.packages,

      'static!': function (content: string, _path: string, type: string) {
        const name = mime.getType(type)
        if (name?.startsWith('image')) {
          return `data:${name};charset=utf-8;base64,${btoa(content)}`
        }
        if (type === '.json') {
          return JSON.parse(content)
        }
        throw new Error(`${type} unable to parse`)
      },
    },
    async handleModule(type: string, getContentData: () => any) {
      if (type === '.vue') {
        return undefined
      }
      if (type === '.json') {
        const contentData = await getContentData()

        const { render: JsonRender } = index.useJsonSchema({
          data: contentData?.nodes || {},
          context: contentData?.data || {},
        })

        return () => <JsonRender />
      }
      if (type === '.mjs') {
        return undefined
      }
      return getContentData()
    },
    customBlockHandler(block) {
      if (block.type === 'i18n') {
        const messages = JSON.parse(block.content)
        for (const locale in messages) {
          mergeLocale(locale, messages[locale])
        }
      }
    },
    getFile: async (url) => {
      url = removeSuffix(url, '.vue')
      url = removeSuffix(url, '.json')

      const res = await client.request({
        path: typeof config?.remote?.apiRoutePath === 'function' ? config?.remote?.apiRoutePath(url) : config?.remote?.apiRoutePath || `static`,
        payload: {
          path: url,
        },
        method: config?.remote?.apiMethod || 'POST',
      }).then((res) => {
        return res?.data
      }).catch((err) => {
        throw new Error(`${err?.message} ${url}`)
      })

      let fileType = res?.type || '.vue'

      if (res?.type?.endsWith('js') || res?.type?.endsWith('ts') || res?.type?.endsWith('jsx') || res?.type?.endsWith('tsx')) {
        fileType = '.mjs'
      }

      return {
        content: res?.content,
        type: fileType,
      }
    },
    getResource({ refPath, relPath }, options: Options): Resource {
      const { moduleCache, pathResolve, getFile } = options

      const [resourceRelPath, ...loaders] = relPath.match(/([^!]+!)|[^!]+$/g).reverse()

      const processContentThroughLoaders = (content, path, type, options) => {
        return loaders.reduce((content, loader) => {
          return moduleCache[loader](content, path, type, options)
        }, content)
      }

      const path = pathResolve({ refPath, relPath: resourceRelPath }, options)
      const id = loaders.join('') + path

      const isPackage = (p: string) => {
        if (p.startsWith('@'))
          return true
        return !p.includes('/') && !p.startsWith('.')
      }

      return {
        id,
        path,
        async getContent() {
          if (isPackage(path)) {
            throw new Error(`Package ${path} not imported`)
          }

          const { content, type } = await getFile(path)

          return {
            getContentData: async (_asBinary: boolean) => processContentThroughLoaders(content, path, type, options),
            type,
          }
        },
      }
    },
    addStyle(textContent) {
      const hash = hashString(textContent)

      if (styleCache.has(hash)) {
        return
      }

      styleCache.set(hash, true)

      const style = document.createElement('style')
      style.textContent = textContent
      style.setAttribute('data-hash', hash)

      document.head.appendChild(style)
    },
  }

  return () => loadModule(`${path}`, { ...options })
}

function removeSuffix(url: string, suffix: string) {
  const regex = new RegExp(`${suffix}$`)
  return url.replace(regex, '')
}



---
File: /packages/core/src/components/loader/remote/render.tsx
---

import { defineAsyncComponent, defineComponent } from 'vue'
import { useRoute } from 'vue-router'
import { useRouteStore } from '../../../stores'
import { sfcLoader } from './loader'

export const DuxRemoteRender = defineComponent({
  name: 'DuxRemoteRender',
  setup(_props) {
    const route = useRoute()
    const routeStore = useRouteStore()
    const info = routeStore.searchRouteName(route.name as string)

    const AsyncComp = defineAsyncComponent({
      loader: sfcLoader(info?.meta?.path),
    })

    return () => <AsyncComp />
  },
})



---
File: /packages/core/src/components/loader/iframe.tsx
---

import { defineComponent } from 'vue'
import { useRoute } from 'vue-router'

export default defineComponent({
  name: 'DuxLoaderIframe',
  setup(_props) {
    const route = useRoute()
    return () => (
      <iframe src={route.meta?.url as string} style={{ width: '100%', height: '100%', border: 'none' }}></iframe>
    )
  },
})



---
File: /packages/core/src/components/loader/index.ts
---

export { default as DuxLoaderIframe } from './iframe'



---
File: /packages/core/src/components/loader/loader.tsx
---

import { defineComponent } from 'vue'
import { DuxException } from '../status'
import { DuxRemoteRender } from './remote'

export default defineComponent({
  name: 'DuxLoaderRemote',
  setup(_props) {

    return () => (
      <div class="app-remote-loader">
        <DuxException>
          <DuxRemoteRender />
        </DuxException>
      </div>
    )
  },
})



---
File: /packages/core/src/components/overlay/index.ts
---

export * from './overlay'



---
File: /packages/core/src/components/overlay/overlay.tsx
---

import { useExtendOverlay } from '@overlastic/vue'
import { defineAsyncComponent, defineComponent, Transition } from 'vue'

export const DuxOverlay = defineComponent({
  name: 'DuxOverlay',
  props: {
    component: Function,
    componentProps: Object,
    mask: {
      type: Boolean,
      default: true,
    },
    maskClosable: {
      type: Boolean,
      default: true,
    },
    duration: {
      type: Number,
      default: 300,
    },
    zIndex: {
      type: Number,
      default: 1000,
    },
  },
  setup(props) {
    const { visible, resolve, reject } = useExtendOverlay({
      duration: props.duration,
    })

    const params = props?.componentProps || {}
    params.onConfirm = resolve
    params.onClose = reject

    const Modal = defineAsyncComponent(props.component as () => Promise<any>)

    const handleMaskClick = () => {
      if (props.maskClosable) {
        reject()
      }
    }
    return () => (
      <div
        class="fixed inset-0 flex items-center justify-center overflow-auto"
        style={{
          zIndex: props.zIndex,
        }}
      >
        <Transition
          enterActiveClass="transition-opacity"
          enterFromClass="opacity-0"
          enterToClass="opacity-100"
          leaveActiveClass="transition-opacity"
          leaveFromClass="opacity-100"
          leaveToClass="opacity-0"
        >
          {visible.value && props.mask && (
            <div
              class="fixed inset-0 bg-black bg-opacity-30"
              style={{
                transitionDuration: `${props.duration}ms`,
              }}
              onClick={handleMaskClick}
            >
            </div>
          )}
        </Transition>

        <Transition
          enterActiveClass="transition-all"
          enterFromClass="opacity-0 scale-95"
          enterToClass="opacity-100 scale-100"
          leaveActiveClass="transition-all"
          leaveFromClass="opacity-100 scale-100"
          leaveToClass="opacity-0 scale-95"
        >
          {visible.value && (
            <Modal {...params} />
          )}
        </Transition>
      </div>
    )
  },
})



---
File: /packages/core/src/components/status/error.tsx
---

import { defineComponent } from 'vue'

export const DuxError = defineComponent({
  name: 'DuxError',
  setup() {
    return () => (
      <div>
        <h1>500</h1>
        <p>Internal Server Error</p>
      </div>
    )
  },
})



---
File: /packages/core/src/components/status/exception.tsx
---

import { defineComponent, onErrorCaptured, ref } from 'vue'
import { useRoute } from 'vue-router'

export const DuxException = defineComponent({
  name: 'DuxException',
  setup(_props, { slots }) {
    const data = ref<Record<string, any> | null>(null)
    const route = useRoute()

    onErrorCaptured((err) => {
      console.error(err)
      if (!route.name) {
        data.value = {
          title: '404',
          desc: 'Page not found',
        }
      }
      else {
        data.value = {
          title: '500',
          desc: err?.message || 'Internal Server Error',
        }
      }
      return false
    })

    return () => data.value
      ? (
          <div>
            <h1>{data.value?.title || 'Unknown'}</h1>
            <p>{data.value?.desc || 'Unknown Description'}</p>
            <p>Use config.components.exception to configure the exception layout</p>
          </div>
        )
      : slots.default?.()
  },
})



---
File: /packages/core/src/components/status/index.ts
---

export * from './error'
export * from './exception'
export * from './notAuthorized'
export * from './notFound'



---
File: /packages/core/src/components/status/notAuthorized.tsx
---

import { defineComponent } from 'vue'

export const DuxNotAuthorized = defineComponent({
  name: 'DuxNotAuthorized',
  setup() {
    return () => (
      <div>
        <h1>403</h1>
        <p>You are not authorized to access this page</p>
      </div>
    )
  },
})



---
File: /packages/core/src/components/status/notFound.tsx
---

import { defineComponent } from 'vue'

export const DuxNotFound = defineComponent({
  name: 'DuxNotFound',
  setup() {
    return () => (
      <div>
        <h1>404</h1>
        <p>Page not found</p>
      </div>
    )
  },
})



---
File: /packages/core/src/components/index.ts
---

export * from './auth'
export * from './common'
export * from './loader'
export * from './overlay'
export * from './status'



---
File: /packages/core/src/config/color.ts
---

export const themeColor = {
  slate: {
    50: '#f8fafc',
    100: '#f1f5f9',
    200: '#e2e8f0',
    300: '#cbd5e1',
    400: '#94a3b8',
    500: '#64748b',
    600: '#475569',
    700: '#334155',
    800: '#1e293b',
    900: '#0f172a',
    950: '#020617',
  },
  gray: {
    50: '#f9fafb',
    100: '#f3f4f6',
    200: '#e5e7eb',
    300: '#d1d5db',
    400: '#9ca3af',
    500: '#6b7280',
    600: '#4b5563',
    700: '#374151',
    800: '#1f2937',
    900: '#111827',
    950: '#030712',
  },
  zinc: {
    50: '#fafafa',
    100: '#f4f4f5',
    200: '#e4e4e7',
    300: '#d4d4d8',
    400: '#a1a1aa',
    500: '#71717a',
    600: '#52525b',
    700: '#3f3f46',
    800: '#27272a',
    900: '#18181b',
    950: '#09090b',
  },
  neutral: {
    50: '#fafafa',
    100: '#f5f5f5',
    200: '#e5e5e5',
    300: '#d4d4d4',
    400: '#a3a3a3',
    500: '#737373',
    600: '#525252',
    700: '#404040',
    800: '#262626',
    900: '#171717',
    950: '#0a0a0a',
  },
  stone: {
    50: '#fafaf9',
    100: '#f5f5f4',
    200: '#e7e5e4',
    300: '#d6d3d1',
    400: '#a8a29e',
    500: '#78716c',
    600: '#57534e',
    700: '#44403c',
    800: '#292524',
    900: '#1c1917',
    950: '#0c0a09',
  },
  red: {
    50: '#fef2f2',
    100: '#fee2e2',
    200: '#fecaca',
    300: '#fca5a5',
    400: '#f87171',
    500: '#ef4444',
    600: '#dc2626',
    700: '#b91c1c',
    800: '#991b1b',
    900: '#7f1d1d',
    950: '#450a0a',
  },
  orange: {
    50: '#fff7ed',
    100: '#ffedd5',
    200: '#fed7aa',
    300: '#fdba74',
    400: '#fb923c',
    500: '#f97316',
    600: '#ea580c',
    700: '#c2410c',
    800: '#9a3412',
    900: '#7c2d12',
    950: '#431407',
  },
  amber: {
    50: '#fffbeb',
    100: '#fef3c7',
    200: '#fde68a',
    300: '#fcd34d',
    400: '#fbbf24',
    500: '#f59e0b',
    600: '#d97706',
    700: '#b45309',
    800: '#92400e',
    900: '#78350f',
    950: '#451a03',
  },
  yellow: {
    50: '#fefce8',
    100: '#fef9c3',
    200: '#fef08a',
    300: '#fde047',
    400: '#facc15',
    500: '#eab308',
    600: '#ca8a04',
    700: '#a16207',
    800: '#854d0e',
    900: '#713f12',
    950: '#422006',
  },
  lime: {
    50: '#f7fee7',
    100: '#ecfccb',
    200: '#d9f99d',
    300: '#bef264',
    400: '#a3e635',
    500: '#84cc16',
    600: '#65a30d',
    700: '#4d7c0f',
    800: '#3f6212',
    900: '#365314',
    950: '#1a2e05',
  },
  green: {
    50: '#f0fdf4',
    100: '#dcfce7',
    200: '#bbf7d0',
    300: '#86efac',
    400: '#4ade80',
    500: '#22c55e',
    600: '#16a34a',
    700: '#15803d',
    800: '#166534',
    900: '#14532d',
    950: '#052e16',
  },
  emerald: {
    50: '#ecfdf5',
    100: '#d1fae5',
    200: '#a7f3d0',
    300: '#6ee7b7',
    400: '#34d399',
    500: '#10b981',
    600: '#059669',
    700: '#047857',
    800: '#065f46',
    900: '#064e3b',
    950: '#022c22',
  },
  teal: {
    50: '#f0fdfa',
    100: '#ccfbf1',
    200: '#99f6e4',
    300: '#5eead4',
    400: '#2dd4bf',
    500: '#14b8a6',
    600: '#0d9488',
    700: '#0f766e',
    800: '#115e59',
    900: '#134e4a',
    950: '#042f2e',
  },
  cyan: {
    50: '#ecfeff',
    100: '#cffafe',
    200: '#a5f3fc',
    300: '#67e8f9',
    400: '#22d3ee',
    500: '#06b6d4',
    600: '#0891b2',
    700: '#0e7490',
    800: '#155e75',
    900: '#164e63',
    950: '#083344',
  },
  sky: {
    50: '#f0f9ff',
    100: '#e0f2fe',
    200: '#bae6fd',
    300: '#7dd3fc',
    400: '#38bdf8',
    500: '#0ea5e9',
    600: '#0284c7',
    700: '#0369a1',
    800: '#075985',
    900: '#0c4a6e',
    950: '#082f49',
  },
  blue: {
    50: '#eff6ff',
    100: '#dbeafe',
    200: '#bfdbfe',
    300: '#93c5fd',
    400: '#60a5fa',
    500: '#3b82f6',
    600: '#2563eb',
    700: '#1d4ed8',
    800: '#1e40af',
    900: '#1e3a8a',
    950: '#172554',
  },
  indigo: {
    50: '#eef2ff',
    100: '#e0e7ff',
    200: '#c7d2fe',
    300: '#a5b4fc',
    400: '#818cf8',
    500: '#6366f1',
    600: '#4f46e5',
    700: '#4338ca',
    800: '#3730a3',
    900: '#312e81',
    950: '#1e1b4b',
  },
  violet: {
    50: '#f5f3ff',
    100: '#ede9fe',
    200: '#ddd6fe',
    300: '#c4b5fd',
    400: '#a78bfa',
    500: '#8b5cf6',
    600: '#7c3aed',
    700: '#6d28d9',
    800: '#5b21b6',
    900: '#4c1d95',
    950: '#2e1065',
  },
  purple: {
    50: '#faf5ff',
    100: '#f3e8ff',
    200: '#e9d5ff',
    300: '#d8b4fe',
    400: '#c084fc',
    500: '#a855f7',
    600: '#9333ea',
    700: '#7e22ce',
    800: '#6b21a8',
    900: '#581c87',
    950: '#3b0764',
  },
  fuchsia: {
    50: '#fdf4ff',
    100: '#fae8ff',
    200: '#f5d0fe',
    300: '#f0abfc',
    400: '#e879f9',
    500: '#d946ef',
    600: '#c026d3',
    700: '#a21caf',
    800: '#86198f',
    900: '#701a75',
    950: '#4a044e',
  },
  pink: {
    50: '#fdf2f8',
    100: '#fce7f3',
    200: '#fbcfe8',
    300: '#f9a8d4',
    400: '#f472b6',
    500: '#ec4899',
    600: '#db2777',
    700: '#be185d',
    800: '#9d174d',
    900: '#831843',
    950: '#500724',
  },
  rose: {
    50: '#fff1f2',
    100: '#ffe4e6',
    200: '#fecdd3',
    300: '#fda4af',
    400: '#fb7185',
    500: '#f43f5e',
    600: '#e11d48',
    700: '#be123c',
    800: '#9f1239',
    900: '#881337',
    950: '#4c0519',
  },
}



---
File: /packages/core/src/config/index.ts
---

export * from './color'



---
File: /packages/core/src/directive/index.ts
---

export * from './permission'



---
File: /packages/core/src/directive/permission.ts
---

import type { Directive, DirectiveBinding } from 'vue'
import { useCan } from '../hooks'

export const permissionDirective: Directive = {
  mounted(el: HTMLElement, binding: DirectiveBinding): void {
    const { value } = binding
    if (!value) {
      return
    }
    const can = useCan()
    if (!can(value)) {
      el.parentElement?.removeChild(el)
    }
  },
}



---
File: /packages/core/src/hooks/json/utils/contextManager.ts
---

/**
 * 合并父子上下文
 */
export function mergeContext(parentContext: Record<string, any>, childContext: Record<string, any>): Record<string, any> {
  return {
    ...parentContext,
    ...childContext,
  }
}

/**
 * 从属性中提取上下文
 */
export function extractContext(props: Record<string, any>): Record<string, any> {
  return props._context || {}
}

/**
 * 注入上下文到属性
 */
export function injectContext(props: Record<string, any>, context: Record<string, any>): Record<string, any> {
  if (Object.keys(context).length === 0) {
    return props
  }

  return {
    ...props,
    _context: context,
  }
}

/**
 * 清理属性中的内部字段
 */
export function cleanProps(props: Record<string, any>): Record<string, any> {
  const { _context, ...cleanedProps } = props
  return cleanedProps
}

/**
 * 创建适配器处理结果
 */
export function createAdaptorResult(props: Record<string, any>, options: {
  skip?: boolean
  nodes?: any[]
  cleanKeys?: string[]
} = {}) {
  const cleanedProps = { ...props }

  if (options.cleanKeys) {
    options.cleanKeys.forEach(key => delete cleanedProps[key])
  }

  return {
    props: cleanedProps,
    skip: options.skip,
    nodes: options.nodes,
  }
}

/**
 * 通用条件求值函数
 */
export function evaluateCondition(value: any, context: Record<string, any>, evaluateExpression: (expr: string, ctx: Record<string, any>) => any): boolean {
  if (typeof value === 'string') {
    return Boolean(evaluateExpression(value, context))
  }
  return Boolean(value)
}



---
File: /packages/core/src/hooks/json/utils/expressionParser.ts
---

import jsep from 'jsep'
import { unref } from 'vue'

jsep.addIdentifierChar('$')
jsep.addIdentifierChar('@')

export function parseExpression(expression: string): jsep.Expression | null {
  try {
    return jsep(expression)
  }
  catch (error) {
    console.warn(`Expression parsing failed: ${expression}`, error)
    return null
  }
}

export function evaluateExpression(expression: string, context: Record<string, any>): any {
  const ast = parseExpression(expression)
  if (!ast)
    return undefined

  return evaluateAst(ast, context)
}

function evaluateAst(node: any, context: Record<string, any>): any {
  if (!node || typeof node !== 'object')
    return undefined

  switch (node.type) {
    case 'Literal':
      return node.value

    case 'Identifier':
      return getNestedValue(context, node.name)

    case 'MemberExpression': {
      const object = evaluateAst(node.object, context)
      if (object == null)
        return undefined

      const property = node.computed
        ? evaluateAst(node.property, context)
        : node.property?.name

      // 解包响应式数据
      const unwrappedObject = unref(object)
      return unwrappedObject?.[property]
    }

    case 'BinaryExpression': {
      const left = evaluateAst(node.left, context)
      const right = evaluateAst(node.right, context)

      const ops = {
        '+': () => left + right,
        '-': () => left - right,
        '*': () => left * right,
        '/': () => left / right,
        '%': () => left % right,
        '==': () => left === right,
        '===': () => left === right,
        '!=': () => left !== right,
        '!==': () => left !== right,
        '<': () => left < right,
        '>': () => left > right,
        '<=': () => left <= right,
        '>=': () => left >= right,
      }

      return ops[node.operator]?.() ?? undefined
    }

    case 'LogicalExpression': {
      const left = evaluateAst(node.left, context)

      if (node.operator === '&&')
        return left && evaluateAst(node.right, context)
      if (node.operator === '||')
        return left || evaluateAst(node.right, context)
      if (node.operator === '??')
        return left ?? evaluateAst(node.right, context)

      return undefined
    }

    case 'UnaryExpression': {
      const arg = evaluateAst(node.argument, context)

      if (node.operator === '!')
        return !arg
      if (node.operator === '-')
        return -arg
      if (node.operator === '+')
        return +arg

      return undefined
    }

    case 'ConditionalExpression': {
      const test = evaluateAst(node.test, context)
      return test
        ? evaluateAst(node.consequent, context)
        : evaluateAst(node.alternate, context)
    }

    case 'CallExpression': {
      const callee = evaluateAst(node.callee, context)

      // 解包响应式函数
      const unwrappedCallee = unref(callee)

      if (typeof unwrappedCallee !== 'function') {
        console.warn('Attempting to call non-function value:', unwrappedCallee)
        return undefined
      }

      const args = Array.isArray(node.arguments)
        ? node.arguments.map((arg: any) => {
            const result = evaluateAst(arg, context)
            return unref(result) // 解包参数中的响应式数据
          })
        : []

      try {
        // 获取函数所属的对象作为 this 上下文
        let thisContext
        if (node.callee.type === 'MemberExpression') {
          const object = evaluateAst(node.callee.object, context)
          thisContext = unref(object)
        }

        return unwrappedCallee.apply(thisContext, args)
      }
      catch (error) {
        console.warn('Function call error:', error)
        return undefined
      }
    }

    case 'ArrayExpression': {
      if (!Array.isArray(node.elements))
        return []

      return node.elements.map((element: any) => {
        if (!element)
          return undefined
        const result = evaluateAst(element, context)
        return unref(result)
      })
    }

    default:
      console.warn(`Unsupported expression type: ${node.type}`)
      return undefined
  }
}

function getNestedValue(obj: any, path: string): any {
  if (!path || !obj)
    return undefined

  try {
    return path.split('.').reduce((current, key) => {
      if (current == null)
        return undefined
      // 解包每一层的响应式数据
      const unwrapped = unref(current)
      return unwrapped?.[key]
    }, obj)
  }
  catch {
    return undefined
  }
}

export interface VForParseResult {
  items: any[]
  itemName: string
  indexName: string
}

export function parseVForExpression(expression: string, context: Record<string, any>): VForParseResult {
  const trimmed = expression.trim()

  const tupleMatch = trimmed.match(/^\((\w+),\s*(\w+)\) in (.+)$/)
  if (tupleMatch) {
    const [, itemName, indexName, listExpr] = tupleMatch
    const items = evaluateExpression(listExpr, context)
    const unwrappedItems = unref(items)
    return {
      items: Array.isArray(unwrappedItems) ? unwrappedItems : [],
      itemName,
      indexName,
    }
  }

  const simpleMatch = trimmed.match(/^(\w+) in (.+)$/)
  if (simpleMatch) {
    const [, itemName, listExpr] = simpleMatch
    const items = evaluateExpression(listExpr, context)
    const unwrappedItems = unref(items)
    return {
      items: Array.isArray(unwrappedItems) ? unwrappedItems : [],
      itemName,
      indexName: 'index',
    }
  }

  throw new Error(`Invalid v-for expression: ${expression}`)
}

export function extractVariables(ast: jsep.Expression): string[] {
  const variables = new Set<string>()

  function walk(node: any): void {
    if (!node || typeof node !== 'object')
      return

    switch (node.type) {
      case 'Identifier':
        variables.add(node.name)
        break
      case 'MemberExpression':
        walk(node.object)
        if (node.computed)
          walk(node.property)
        break
      case 'BinaryExpression':
      case 'LogicalExpression':
        walk(node.left)
        walk(node.right)
        break
      case 'UnaryExpression':
        walk(node.argument)
        break
      case 'ConditionalExpression':
        walk(node.test)
        walk(node.consequent)
        walk(node.alternate)
        break
      case 'CallExpression':
        walk(node.callee)
        if (Array.isArray(node.arguments)) {
          node.arguments.forEach((arg: any) => walk(arg))
        }
        break
      case 'ArrayExpression':
        if (Array.isArray(node.elements)) {
          node.elements.forEach((element: any) => {
            if (element)
              walk(element)
          })
        }
        break
    }
  }

  walk(ast)
  return Array.from(variables)
}



---
File: /packages/core/src/hooks/json/index.ts
---

import type { IJsonAdaptor } from './types'
import { vForAdaptor } from './vFor'
import { vIfAdaptor } from './vIf'
import { vModelAdaptor } from './vModel'
import { vOnAdaptor } from './vOn'
import { vShowAdaptor } from './vShow'
import { vTextAdaptor } from './vText'

export const defaultAdaptors: IJsonAdaptor[] = [
  vIfAdaptor,
  vShowAdaptor,
  vForAdaptor,
  vModelAdaptor,
  vOnAdaptor,
  vTextAdaptor,
].sort((a, b) => b.priority - a.priority)

export * from './types'
export {
  vForAdaptor,
  vIfAdaptor,
  vModelAdaptor,
  vOnAdaptor,
  vShowAdaptor,
  vTextAdaptor,
}



---
File: /packages/core/src/hooks/json/types.ts
---

import type { Component } from 'vue'

export interface JsonSchemaNode {
  tag: string | Component
  attrs?: Record<string, any>
  children?: JsonSchemaNode | JsonSchemaNode[] | string
  slots?: Record<string, SlotContent>
  [key: string]: any
}

export type SlotContent =
  | string
  | JsonSchemaNode
  | JsonSchemaNode[]
  | ((slotProps?: any) => SlotContent)

export interface IJsonAdaptorResult {
  props: Record<string, any>
  skip?: boolean
  nodes?: JsonSchemaNode[]
}

export interface IJsonAdaptor {
  name: string
  priority: number
  process: (node: JsonSchemaNode, props: Record<string, any>) => IJsonAdaptorResult | null
}

export interface JsonAdaptorOptions {
  adaptors?: IJsonAdaptor[]
}

export type EventModifier = 'prevent' | 'stop' | 'once' | 'capture' | 'self' | 'passive'

export interface VForConfig {
  list: any[]
  item?: string
  index?: string
}

export type VModelBinding =
  | [object, string]
  | [() => any, (val: any) => void]



---
File: /packages/core/src/hooks/json/vFor.ts
---

import type { IJsonAdaptor, IJsonAdaptorResult, JsonSchemaNode } from './types'
import type { VForParseResult } from './utils/expressionParser'
import { cleanProps, extractContext, injectContext } from './utils/contextManager'
import { parseVForExpression } from './utils/expressionParser'

export const vForAdaptor: IJsonAdaptor = {
  name: 'v-for',
  priority: 90,
  process(node: JsonSchemaNode, props: Record<string, any>): IJsonAdaptorResult | null {
    const vForValue = node.attrs?.['v-for'] || node.attrs?.vFor
    if (!vForValue) {
      return null
    }

    const newAttrs = { ...node.attrs }
    delete newAttrs['v-for']
    delete newAttrs.vFor

    const parentContext = extractContext(props)
    let parseResult: VForParseResult

    try {
      if (Array.isArray(vForValue)) {
        parseResult = {
          items: vForValue,
          itemName: 'item',
          indexName: 'index',
        }
      }
      else if (typeof vForValue === 'object' && vForValue.list) {
        parseResult = {
          items: Array.isArray(vForValue.list) ? vForValue.list : [],
          itemName: vForValue.item || 'item',
          indexName: vForValue.index || 'index',
        }
      }
      else if (typeof vForValue === 'string') {
        parseResult = parseVForExpression(vForValue, parentContext)
      }
      else {
        console.warn('Unsupported v-for format:', vForValue)
        return null
      }
    }
    catch (error) {
      console.warn('v-for parsing failed:', error)
      return null
    }

    const nodes: JsonSchemaNode[] = parseResult.items.map((item, index) => {
      const itemContext = {
        [parseResult.itemName]: item,
        [parseResult.indexName]: index,
      }

      const mergedContext = { ...parentContext, ...itemContext }

      return {
        ...node,
        attrs: {
          ...newAttrs,
          key: `${parseResult.itemName}_${index}`,
          ...injectContext({}, mergedContext),
        },
      }
    })

    return {
      props: cleanProps(props),
      nodes,
    }
  },
}



---
File: /packages/core/src/hooks/json/vIf.ts
---

import type { IJsonAdaptor, JsonSchemaNode } from './types'
import { createAdaptorResult, evaluateCondition, extractContext } from './utils/contextManager'
import { evaluateExpression } from './utils/expressionParser'

export const vIfAdaptor: IJsonAdaptor = {
  name: 'v-if',
  priority: 100,
  process(node: JsonSchemaNode, props: Record<string, any>) {
    const attrs = node.attrs || {}
    const context = extractContext(props)

    let condition: any

    if (attrs['v-if'] !== undefined) {
      condition = evaluateCondition(attrs['v-if'], context, evaluateExpression)
    }
    else if (attrs['v-else-if'] !== undefined) {
      condition = evaluateCondition(attrs['v-else-if'], context, evaluateExpression)
    }
    else if (attrs['v-else'] !== undefined) {
      condition = true
    }

    if (condition === undefined) {
      return null
    }

    return createAdaptorResult(props, {
      skip: !condition,
      cleanKeys: ['v-if', 'v-else-if', 'v-else'],
    })
  },
}



---
File: /packages/core/src/hooks/json/vModel.ts
---

import type { IJsonAdaptor, VModelBinding } from './types'
import { toRef } from 'vue'
import { extractContext } from './utils/contextManager'
import { evaluateExpression } from './utils/expressionParser'

export const vModelAdaptor: IJsonAdaptor = {
  name: 'v-model',
  priority: 70,
  process(_node, props) {
    const modelProps: Record<string, any> = {}
    const restProps: Record<string, any> = {}
    let hasModel = false
    const context = extractContext(props)

    Object.entries(props).forEach(([key, value]) => {
      if (key.startsWith('v-model') || key.startsWith('vModel')) {
        hasModel = true

        const [modelPart, ...modifiers] = key.split('.')

        let modelName: string
        if (modelPart === 'v-model' || modelPart === 'vModel') {
          modelName = 'modelValue'
        }
        else if (modelPart.startsWith('v-model:')) {
          modelName = modelPart.slice(8)
        }
        else if (modelPart.startsWith('vModel:')) {
          modelName = modelPart.slice(7)
        }
        else {
          modelName = 'modelValue'
        }

        try {
          const { modelValue, updateFn } = createModelBinding(value as VModelBinding, modifiers, context)

          modelProps[modelName] = modelValue
          modelProps[`onUpdate:${modelName}`] = updateFn
        }
        catch (error) {
          console.error(`v-model binding error (${modelName}):`, error)
        }
      }
      else {
        restProps[key] = value
      }
    })

    return hasModel ? { props: { ...restProps, ...modelProps } } : null
  },
}

function createModelBinding(value: VModelBinding | any, modifiers: string[], context: Record<string, any>) {
  // 如果是字符串表达式，尝试从 context 中解析
  if (typeof value === 'string') {
    // 简单的路径解析，如 'row.name' -> context.row.name
    const getValue = () => {
      try {
        return evaluateExpression(value, context)
      }
      catch (error) {
        console.warn(`v-model: Failed to evaluate expression "${value}"`, error)
        return undefined
      }
    }

    const setValue = (newValue: any) => {
      try {
        // 解析路径，如 'row.name' -> ['row', 'name']
        const parts = value.split('.')
        if (parts.length >= 2) {
          const objPath = parts.slice(0, -1).join('.')
          const propName = parts[parts.length - 1]
          const obj = evaluateExpression(objPath, context)

          if (obj && typeof obj === 'object') {
            obj[propName] = applyModifiers(newValue, modifiers)
            return
          }
        }
        console.warn(`v-model: Cannot update expression "${value}". Target object not found.`)
      }
      catch (error) {
        console.warn(`v-model: Failed to update expression "${value}"`, error)
      }
    }

    return {
      modelValue: getValue(),
      updateFn: setValue,
    }
  }

  if (Array.isArray(value) && value.length === 2
    && typeof value[0] === 'function' && typeof value[1] === 'function') {
    const [getter, setter] = value

    return {
      modelValue: getter(),
      updateFn: (newValue: any) => {
        setter(applyModifiers(newValue, modifiers))
      },
    }
  }

  if (Array.isArray(value) && value.length === 2) {
    const [obj, prop] = value

    if (!obj || typeof prop !== 'string') {
      throw new Error('Invalid v-model binding format: [obj, prop] expected')
    }

    const valueRef = toRef(obj, prop)

    return {
      modelValue: valueRef.value,
      updateFn: (newValue: any) => {
        valueRef.value = applyModifiers(newValue, modifiers)
      },
    }
  }

  const valueRef = toRef(value)

  if (valueRef === value && typeof value !== 'object') {
    return {
      modelValue: value,
      updateFn: () => {
        console.warn('v-model: Cannot update non-reactive value. Please use ref, [obj, prop], or [getter, setter] format.')
      },
    }
  }

  return {
    modelValue: valueRef.value,
    updateFn: (newValue: any) => {
      valueRef.value = applyModifiers(newValue, modifiers)
    },
  }
}

function applyModifiers(value: any, modifiers: string[]): any {
  return modifiers.reduce((val, modifier) => {
    switch (modifier) {
      case 'trim':
        return typeof val === 'string' ? val.trim() : val
      case 'number': {
        const num = Number(val)
        return Number.isNaN(num) ? val : num
      }
      case 'lazy':
        return val
      default:
        console.warn(`Unknown v-model modifier: ${modifier}`)
        return val
    }
  }, value)
}



---
File: /packages/core/src/hooks/json/vOn.ts
---

import type { IJsonAdaptor } from './types'

export const vOnAdaptor: IJsonAdaptor = {
  name: 'v-on',
  priority: 60,
  process(_node, props) {
    const eventProps: Record<string, any> = {}
    const restProps: Record<string, any> = {}
    let hasEvents = false

    Object.entries(props).forEach(([key, value]) => {
      if (key.startsWith('@') || key.startsWith('v-on:')) {
        hasEvents = true

        const eventPart = key.startsWith('@') ? key.slice(1) : key.slice(5)
        const [eventName, ...modifiers] = eventPart.split('.')

        if (!eventName) {
          console.warn(`Invalid event name: ${key}`)
          return
        }

        const handlerName = `on${eventName.charAt(0).toUpperCase()}${eventName.slice(1)}`

        const handler = (event: Event, ...args: any[]) => {
          if (modifiers.includes('prevent'))
            event.preventDefault?.()
          if (modifiers.includes('stop'))
            event.stopPropagation?.()
          try {
            if (typeof value === 'function') {
              return value(event, ...args)
            }
            else {
              console.warn(`Invalid event handler type: ${typeof value}`)
            }
          }
          catch (error) {
            console.error(`Event handler execution error (${eventName}):`, error)
          }
        }

        eventProps[handlerName] = handler
      }
      else {
        restProps[key] = value
      }
    })

    return hasEvents ? { props: { ...restProps, ...eventProps } } : null
  },
}



---
File: /packages/core/src/hooks/json/vShow.ts
---

import type { IJsonAdaptor, JsonSchemaNode } from './types'
import { evaluateCondition, extractContext } from './utils/contextManager'
import { evaluateExpression } from './utils/expressionParser'

export const vShowAdaptor: IJsonAdaptor = {
  name: 'v-show',
  priority: 95,
  process(node: JsonSchemaNode, props: Record<string, any>) {
    const vShowValue = node.attrs?.['v-show']
    if (vShowValue === undefined)
      return null

    const context = extractContext(props)
    const show = evaluateCondition(vShowValue, context, evaluateExpression)

    const cleanProps = { ...props }
    delete cleanProps['v-show']

    const currentStyle = cleanProps.style || {}
    const newStyle = typeof currentStyle === 'object'
      ? { ...currentStyle, display: show ? undefined : 'none' }
      : { display: show ? undefined : 'none' }

    return {
      props: {
        ...cleanProps,
        style: newStyle,
      },
    }
  },
}



---
File: /packages/core/src/hooks/json/vText.ts
---

import type { IJsonAdaptor, IJsonAdaptorResult, JsonSchemaNode } from './types'
import { evaluateExpression } from './utils/expressionParser'

/**
 * 检查字符串是否包含插值表达式
 */
function hasInterpolation(str: string): boolean {
  return typeof str === 'string' && /\{\{.+?\}\}/.test(str)
}

/**
 * 处理字符串插值
 */
function processStringInterpolation(text: string, context: Record<string, any>): string {
  if (!hasInterpolation(text)) {
    return text
  }

  return text.replace(/\{\{([^}]+)\}\}/g, (match, expression) => {
    try {
      const result = evaluateExpression(expression.trim(), context)
      return String(result ?? '')
    }
    catch (error) {
      console.warn(`Interpolation expression evaluation failed: ${expression}`, error)
      return match
    }
  })
}

export const vTextAdaptor: IJsonAdaptor = {
  name: 'v-text',
  priority: 50,
  process(node: JsonSchemaNode, props: Record<string, any>): IJsonAdaptorResult | null {
    const context = props._context || {}
    let hasChanges = false
    let childrenChanged = false

    const processedProps: Record<string, any> = {}
    Object.entries(props).forEach(([key, value]) => {
      if (typeof value === 'string' && hasInterpolation(value)) {
        const newValue = processStringInterpolation(value, context)
        if (newValue !== value) {
          processedProps[key] = newValue
          hasChanges = true
        }
        else {
          processedProps[key] = value
        }
      }
      else {
        processedProps[key] = value
      }
    })

    let processedChildren = node.children
    if (typeof node.children === 'string' && hasInterpolation(node.children)) {
      const newText = processStringInterpolation(node.children, context)
      if (newText !== node.children) {
        processedChildren = newText
        hasChanges = true
        childrenChanged = true
      }
    }

    if (!hasChanges) {
      return null
    }

    if (childrenChanged) {
      const newNode = {
        ...node,
        attrs: node.attrs,
        children: processedChildren,
      }
      return {
        props: processedProps,
        nodes: [newNode],
      }
    }

    return {
      props: processedProps,
    }
  },
}



---
File: /packages/core/src/hooks/upload/index.ts
---

export * from './types'
export * from './local'
export * from './s3'


---
File: /packages/core/src/hooks/upload/local.ts
---

import type { IDataProviderResponse } from '../../types'
import type { IUploadDriver, IUploadDriverOptions } from './types'
import { useClient } from '../data'

export function createLocalUploadDriver(): IUploadDriver {
  const client = useClient()
  return {
    upload(file: File, options: IUploadDriverOptions): Promise<IDataProviderResponse> {
      const query: Record<string, any> = options.query || {}
      let payload: File | FormData | null = null

      if (options.method === 'PUT') {
        Object.entries(options.params || {}).forEach(([key, value]) => {
          query[key] = value
        })
        payload = file
      }
      else {
        const formData = new FormData()
        formData.append('file', file)
        Object.entries(options.params || {}).forEach(([key, value]) => {
          formData.append(key, value)
        })
        payload = formData
      }

      return client.request({
        ...options,
        query,
        method: options.method || 'POST',
        payload,
        signal: options.signal,
        onUploadProgress: options.onUploadProgress,
      })
    },
  }
}



---
File: /packages/core/src/hooks/upload/s3.ts
---

import type { IDataProviderResponse } from '../../types'
import { useClient } from '../data'
import type { IUploadDriver, IUploadDriverOptions } from './types'
import axios from 'axios'

export interface IS3SignData {
  uploadUrl: string
  url: string
  params?: Record<string, string>
}

export function createS3UploadDriver(config: {
  signPath: string
  signCallback?: (response: IDataProviderResponse) => IS3SignData
  [key: string]: any
}): IUploadDriver {

  const client = useClient()

  return {
    async upload(file: File, options: IUploadDriverOptions): Promise<IDataProviderResponse> {

      const signResponse = await client.request({
        method: 'GET',
        path: config.signPath,
        query: {
          name: file.name,
          size: file.size,
          mime: file.type,
          ...options.params,
        },
        signal: options.signal,
        onUploadProgress: options.onUploadProgress,
      })

      const signData = config.signCallback?.(signResponse) || {
        uploadUrl: signResponse.data?.uploadUrl,
        url: signResponse.data?.url,
        params: signResponse.data?.params
      }

      if (!signData.uploadUrl) {
        throw new Error('Upload URL is required')
      }

      if (!signData.url) {
        throw new Error('File URL is required')
      }

      const method = options.method || 'POST'
      let uploadPayload: File | FormData | null = null
      const headers = options.headers || {}

      if (method === 'PUT') {
        uploadPayload = file
        headers['Content-Type'] = file.type || 'application/octet-stream'
      } else {
        const formData = new FormData()
        formData.append('Content-Type', file.type || 'application/octet-stream')
        formData.append('file', file)
        if (signData.params) {
          Object.entries(signData.params).forEach(([key, value]) => {
            formData.append(key, String(value))
          })
        }
        uploadPayload = formData
      }

      const uploadResponse = await axios.request({
        method,
        url: signData.uploadUrl,
        data: uploadPayload,
        signal: options.signal,
        headers,
        onUploadProgress: (progressEvent) => {
          if (options.onUploadProgress && progressEvent.total) {
            const percent = Math.round((progressEvent.loaded * 100) / progressEvent.total)
            options.onUploadProgress({
              loaded: progressEvent.loaded,
              total: progressEvent.total,
              percent,
            })
          }
        },
      })

      if (uploadResponse.status < 200 || uploadResponse.status >= 300) {
        throw new Error(`S3 upload failed: ${uploadResponse.statusText}`)
      }

      return {
        data: {
          url: signData.url,
          filename: file.name,
          size: file.size,
          mime: file.type,
        },
        message: 'upload successful',
      }
    }
  }
}


---
File: /packages/core/src/hooks/upload/types.ts
---

import type { IDataProviderCustomOptions, IDataProviderResponse } from '../../types'

export interface IUploadDriver {
  upload: (file: File, options: IUploadDriverOptions) => Promise<IDataProviderResponse>
}

export interface IUploadDriverOptions extends Omit<IDataProviderCustomOptions, 'onUploadProgress' | 'onDownloadProgress'> {
  method?: 'POST' | 'PUT'
  signal?: AbortSignal
  onUploadProgress?: (progressData: {
    loaded: number
    total?: number
    percent?: number
  }) => void
  params?: Record<string, string>
}



---
File: /packages/core/src/hooks/auth.ts
---

import type { IAuthActionResponse, IAuthCheckResponse, IAuthErrorResponse, IAuthLoginResponse, IAuthLogoutResponse, IDataProviderError } from '../types'
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '../stores/auth'
import { useManage } from './manage'

/**
 * Auth login params
 */
export interface IAuthLoginParams {
  onSuccess?: (data?: IAuthLoginResponse) => void
  onError?: (error?: IAuthLoginResponse) => void
}

/**
 * Auth logout params
 */
export interface IAuthLogoutParams {
  onSuccess?: (data?: IAuthLogoutResponse) => void
  onError?: (error?: IAuthLogoutResponse) => void
}

/**
 * Auth check params
 */
export interface IAuthCheckParams {
  onSuccess?: (data?: IAuthCheckResponse) => void
  onError?: (error?: IAuthCheckResponse) => void
}

/**
 * Auth action params
 */
export interface IAuthActionParams {
  onSuccess?: (data?: IAuthActionResponse) => void
  onError?: (error?: IAuthActionResponse) => void
}

/**
 * Login
 * login to manage
 * @param onSuccess Login success callback
 * @param onError Login error callback
 * @returns Login method
 */
export function useLogin(props?: IAuthLoginParams) {
  const manage = useManage()
  const authStore = useAuthStore()
  const router = useRouter()
  const loading = ref(false)

  const mutate = async (data: Record<string, any>) => {
    loading.value = true
    const result = await manage.config.authProvider?.login(data, manage)
    loading.value = false
    if (result?.success) {
      if (!result?.data) {
        throw new Error('Login response data is undefined')
      }
      props?.onSuccess?.(result)
      authStore.login(result.data)
      router.push(manage.getRoutePath(result.redirectTo || '/'))
      return
    }
    props?.onError?.(result)
  }

  return {
    mutate,
    isLoading: loading,
  }
}

/**
 * Logout
 * logout from manage
 * @param onSuccess Logout success callback
 * @param onError Logout error callback
 * @returns Logout method
 */
export function useLogout(props?: IAuthLogoutParams) {
  const manage = useManage()
  const authStore = useAuthStore()
  const router = useRouter()

  const mutate = async (params?: any) => {
    const result = await manage.config.authProvider?.logout(params, manage)
    if (result?.success) {
      props?.onSuccess?.(result)
      authStore.logout()
      await router.replace(manage.getRoutePath(result.redirectTo || '/login'))
      setTimeout(() => {
        window.location.reload()
      }, 100)
      return
    }
    props?.onError?.(result)
  }

  return {
    mutate,
  }
}

/**
 * Check
 * check auth
 * @param onSuccess Check success callback
 * @param onError Check error callback
 * @returns Check method
 */
export function useCheck(props?: IAuthCheckParams) {
  const manage = useManage()
  const authStore = useAuthStore()
  const router = useRouter()

  const mutate = async (params?: any) => {
    const result = await manage.config.authProvider?.check?.(params, manage, authStore.getUser())
    if (result?.success) {
      props?.onSuccess?.(result)
      if (!result?.data) {
        throw new Error('Check response data is undefined')
      }
      authStore.update(result.data)
      return
    }
    props?.onError?.(result)
    if (!result?.logout) {
      return
    }
    await router.replace(manage.getRoutePath(result.redirectTo || '/login'))
    setTimeout(() => {
      window.location.reload()
    }, 100)
  }

  return {
    mutate,
  }
}

/**
 * Register
 * register to manage
 * @param onSuccess Register success callback
 * @param onError Register error callback
 * @returns Register method
 */
export function useRegister(props?: IAuthLoginParams) {
  const manage = useManage()
  const authStore = useAuthStore()
  const router = useRouter()
  const mutate = async (data: Record<string, any>) => {
    const result = await manage.config.authProvider?.register?.(data, manage)
    if (result?.success) {
      props?.onSuccess?.(result)
      if (!result?.data) {
        throw new Error('Register response data is undefined')
      }
      authStore.login(result.data)
      router.push(manage.getRoutePath(result.redirectTo || '/'))
      return
    }
    props?.onError?.(result)
  }
  return {
    mutate,
  }
}

/**
 * Forgot password
 * @param onSuccess Forgot password success callback
 * @param onError Forgot password error callback
 * @returns Forgot password method
 */
export function useForgotPassword(props?: IAuthActionParams) {
  const manage = useManage()
  const router = useRouter()

  const mutate = async (params?: any) => {
    const result = await manage.config.authProvider?.forgotPassword?.(params, manage)
    if (result?.success) {
      props?.onSuccess?.(result)
      if (result.redirectTo) {
        router.push(manage.getRoutePath(result.redirectTo || '/'))
      }
      return
    }
    props?.onError?.(result)
  }

  return {
    mutate,
  }
}

/**
 * Update password
 * @param onSuccess Update password success callback
 * @param onError Update password error callback
 * @returns Update password method
 */
export function useUpdatePassword(props?: IAuthActionParams) {
  const manage = useManage()
  const router = useRouter()

  const mutate = async (params?: any) => {
    const result = await manage.config.authProvider?.updatePassword?.(params, manage)
    if (result?.success) {
      props?.onSuccess?.(result)
      if (result.redirectTo) {
        router.push(manage.getRoutePath(result.redirectTo || '/'))
      }
      return
    }
    props?.onError?.(result)
  }

  return {
    mutate,
  }
}

/**
 * Error
 * handle auth error
 * @param onCallback Error callback
 * @returns Error method
 */
export function useError(onCallback?: (data?: IAuthErrorResponse) => void) {
  const { config: manage, getRoutePath } = useManage()
  const router = useRouter()
  const authStore = useAuthStore()

  const mutate = async (error?: IDataProviderError) => {
    const result = await manage.authProvider?.onError(error)
    onCallback?.(result)
    if (result?.logout) {
      authStore.logout()
      await router.replace(getRoutePath(result.redirectTo || '/login'))
      setTimeout(() => {
        window.location.reload()
      }, 100)
    }
  }
  return {
    mutate,
  }
}

/**
 * Get auth
 * get auth info
 * @returns Auth info
 */
export function useGetAuth(manageName?: string) {
  const authStore = useAuthStore(manageName)
  const user = authStore.getUser()
  return user
}

/**
 * Is login
 * check if user is login
 * @returns Is login
 */
export function useIsLogin(manageName?: string) {
  const authStore = useAuthStore(manageName)
  return authStore.isLogin()
}

/**
 * Can
 * check if user can access the route
 * @param manageName Manage name
 * @returns Can method
 */
export function useCan(manageName?: string) {
  const manage = useManage(manageName)
  const authStore = useAuthStore(manageName)
  const user = authStore.getUser()

  const can = (name: string, params?: any) => {
    if (manage.config.authProvider?.can) {
      return manage.config.authProvider.can(name, params, manage, user)
    }
    return true
  }

  return can
}



---
File: /packages/core/src/hooks/config.ts
---

import type { IConfig } from '../types'
import { inject } from 'vue'

/**
 * Config
 * get global config
 * @returns Config
 */
export function useConfig(): IConfig {
  const config = inject<IConfig>('dux.config')
  if (!config) {
    throw new Error('config is not defined')
  }

  return config
}



---
File: /packages/core/src/hooks/data.ts
---

/* eslint-disable @tanstack/query/exhaustive-deps */
import type { DefaultError, DefinedInitialDataInfiniteOptions, DefinedInitialQueryOptions, InfiniteData, UseMutationOptions } from '@tanstack/vue-query'
import type { IDataProviderCreateManyOptions, IDataProviderCreateOptions, IDataProviderCustomOptions, IDataProviderDeleteManyOptions, IDataProviderDeleteOptions, IDataProviderError, IDataProviderGetManyOptions, IDataProviderGetOneOptions, IDataProviderListOptions, IDataProviderPagination, IDataProviderResponse, IDataProviderUpdateManyOptions, IDataProviderUpdateOptions } from '../types'
import { useInfiniteQuery, useMutation, useQuery, useQueryClient } from '@tanstack/vue-query'
import { computed, ref, toRef, watch } from 'vue'
import { useError, useGetAuth } from './auth'
import { useManage } from './manage'

type IDataQueryOptions = Partial<DefinedInitialQueryOptions<IDataProviderResponse | undefined, DefaultError, IDataProviderResponse | undefined, any>>
type IDataQueryOptionsInfinite = Partial<DefinedInitialDataInfiniteOptions<IDataProviderResponse | undefined, DefaultError, InfiniteData<IDataProviderResponse | undefined>, any, number>>

export interface IListParams extends IDataProviderListOptions {
  providerName?: string
  options?: IDataQueryOptions
  onError?: (error: IDataProviderError) => void
}

/**
 * Get list data
 * @param params
 */
export function useList(params: IListParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'

  const { mutate: onAuthError } = useError()

  const pagination = toRef<IDataProviderPagination>(params.pagination ? params.pagination as IDataProviderPagination : { page: 1, pageSize: 20 })
  const sorters = toRef(params, 'sorters', {})
  const filters = toRef(params, 'filters', {})
  const meta = toRef(params, 'meta', {})

  const props = computed((): IDataProviderListOptions => {
    const { onError, options, pagination, filters, sorters, meta, ...rest } = params
    return rest
  })

  watch(props, () => {
    if (!params.pagination) {
      return
    }
    pagination.value.page = 1
  }, {
    deep: true,
  })

  const queryProps = computed(() => {
    return {
      ...props.value,
      pagination: params.pagination ? pagination.value : undefined,
      filters: filters.value || {},
      sorters: sorters.value || {},
      meta: meta.value || {},
    }
  })

  const req = useQuery({
    queryKey: [`${manage.config?.name}:${providerName}:${params.path}`, queryProps.value],
    queryFn: () => manage.config?.dataProvider?.[providerName]?.getList(queryProps.value, manage, auth),
    ...params.options,
  })

  const isLoading = computed<boolean>(() => {
    return req.isFetching.value
  })

  watch(req.isError, (v) => {
    if (!v) {
      return
    }
    onAuthError(req.error.value as IDataProviderError)
    params?.onError?.(req.error.value as IDataProviderError)
  })

  const data = ref<IDataProviderResponse | undefined>(undefined)
  const total = ref(0)
  const pageCount = ref(0)

  watch(req.data, (v) => {
    if (!v) {
      return
    }
    data.value = v
    total.value = manage.config?.dataProvider?.[providerName]?.getTotal?.(v) || 0
    pageCount.value = Math.ceil(total.value / (pagination.value.pageSize || 20)) || 0
  }, {
    immediate: true,
  })

  return {
    ...req,
    isLoading,
    data,
    refetch: req.refetch,
    pagination,
    total,
    pageCount,
  }
}

export interface IInfiniteListParams extends IDataProviderListOptions {
  providerName?: string
  pagination?: IDataProviderPagination
  options?: IDataQueryOptionsInfinite
  onError?: (error: IDataProviderError) => void
}

/**
 * Get infinite list data
 * @param params
 */
export function useInfiniteList(params: IInfiniteListParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()

  const pagination = toRef(params, 'pagination', { page: 1, pageSize: 20 })
  const sorters = toRef(params, 'sorters', {})
  const filters = toRef(params, 'filters', {})
  const meta = toRef(params, 'meta', {})

  const props = computed((): IDataProviderListOptions => {
    const { onError, options, pagination, filters, sorters, meta, ...rest } = params
    return rest
  })

  watch(props, () => {
    pagination.value.page = 1
  }, {
    deep: true,
  })

  const total = ref(0)
  const pageCount = ref(0)

  const queryProps = computed(() => {
    return {
      ...props.value,
      filters: filters.value || {},
      sorters: sorters.value || {},
      meta: meta.value || {},
    }
  })

  const req = useInfiniteQuery({
    queryKey: [`${manage.config?.name}:${providerName}:${params.path}:infinite`, queryProps.value],
    queryFn: ({ pageParam }) => {
      pagination.value.page = pageParam
      return manage.config?.dataProvider?.[providerName]?.getList({
        ...queryProps.value,
        pagination: {
          ...pagination.value,
          page: pageParam,
        },
      }, manage, auth)
    },
    initialPageParam: 1,
    getNextPageParam: (lastPage, _allPages, lastPageParam) => {
      if (!lastPage?.data || !lastPage?.data?.length) {
        return
      }

      const resTotal = manage.config?.dataProvider?.[providerName]?.getTotal?.(lastPage) || 0
      pageCount.value = Math.ceil(resTotal / (pagination.value.pageSize || 20)) || 0
      total.value = resTotal

      const currentTotal = lastPageParam * (pagination.value.pageSize || 20)
      if (currentTotal >= resTotal) {
        return
      }

      return lastPageParam + 1
    },
    getPreviousPageParam: (firstPage, _allPages, firstPageParam) => {
      if (firstPageParam <= 1) {
        return
      }
      const resTotal = manage.config?.dataProvider?.[providerName]?.getTotal?.(firstPage) || 0
      pageCount.value = Math.ceil(resTotal / (pagination.value.pageSize || 20)) || 0
      total.value = resTotal
      return firstPageParam - 1
    },
    ...params.options,
  })

  const isLoading = computed<boolean>(() => {
    return req.isFetching.value
  })

  watch(req.isError, (v) => {
    if (!v) {
      return
    }
    onAuthError(req.error.value as IDataProviderError)
    params?.onError?.(req.error.value as IDataProviderError)
  })

  const fetchNextPage = () => {
    if (!req.hasNextPage.value || req.isFetching.value) {
      return
    }
    return req.fetchNextPage()
  }

  const data = ref<IDataProviderResponse | undefined>(undefined)
  watch(req.data, (v) => {
    if (!v || !v?.pages || !v.pages?.length) {
      return
    }
    const allData = v.pages.reduce((acc, page) => {
      if (page?.data && Array.isArray(page.data) && page.data?.length) {
        return acc.concat(page.data)
      }
      return acc
    }, [] as any[])

    const firstPage = v.pages[0]
    if (firstPage) {
      data.value = {
        ...firstPage,
        data: allData,
      }
    }
  }, {
    deep: true,
    immediate: true,
  })

  return {
    ...req,
    isLoading,
    data,
    fetchNextPage,
    hasNextPage: req.hasNextPage,
    refetch: req.refetch,
    pagination,
    total,
    pageCount,
  }
}

export interface IOneParams extends IDataProviderGetOneOptions {
  providerName?: string
  options?: IDataQueryOptions
  onError?: (error: IDataProviderError) => void
}

/**
 * Get one data
 * @param params
 */
export function useOne(params: IOneParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()

  const props = computed((): IDataProviderGetOneOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useQuery({
    queryKey: [`${manage.config?.name}:${providerName}:${params.path}`, props],
    queryFn: () => manage.config?.dataProvider?.[providerName]?.getOne(props.value, manage, auth),
    ...params.options,
  })

  const isLoading = computed<boolean>(() => {
    if (req.isFetched.value) {
      return false
    }
    return req.isFetching.value
  })

  watch(req.isError, (v) => {
    if (!v) {
      return
    }
    onAuthError(req.error.value as IDataProviderError)
    params?.onError?.(req.error.value as IDataProviderError)
  }, {
    immediate: true,
  })

  const data = ref<IDataProviderResponse | undefined>(undefined)
  watch(req.data, (v) => {
    if (!v) {
      return
    }
    data.value = v
  }, {
    immediate: true,
  })

  return {
    ...req,
    isLoading,
    data,
    refetch: req.refetch,
  }
}

export interface IManyParams extends IDataProviderGetManyOptions {
  providerName?: string
  options?: IDataQueryOptions
  onError?: (error: IDataProviderError) => void
}
/**
 * Get many data
 * @param params
 */
export function useMany(params: IManyParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()

  const props = computed((): IDataProviderGetManyOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useQuery({
    queryKey: [`${manage.config?.name}:${providerName}:${params.path}`, props],
    queryFn: () => manage.config?.dataProvider?.[providerName]?.getMany(props.value, manage, auth),
    ...params.options,
  })

  const isLoading = computed<boolean>(() => {
    if (req.isFetched.value) {
      return false
    }
    return req.isFetching.value
  })

  watch(req.isError, (v) => {
    if (!v) {
      return
    }
    onAuthError(req.error.value as IDataProviderError)
    params?.onError?.(req.error.value as IDataProviderError)
  })

  const data = ref<IDataProviderResponse | undefined>(undefined)
  watch(req.data, (v) => {
    if (!v) {
      return
    }
    data.value = v
  }, {
    immediate: true,
  })

  return {
    ...req,
    isLoading,
    data,
    refetch: req.refetch,
  }
}

export interface ICreateParams extends IDataProviderCreateOptions {
  providerName?: string
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderCreateOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
}

/**
 * Create data
 * @param params
 */
export function useCreate(params: ICreateParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()
  const { invalidate } = useInvalidate()

  const props = computed((): IDataProviderCreateOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useMutation({
    mutationFn: (data) => {
      if (!manage.config?.dataProvider) {
        throw new Error('Data provider is not initialized')
      }
      if (data.path) {
        params.path = data.path
      }
      return manage.config?.dataProvider?.[providerName]?.create({
        ...props.value,
        ...data,
      }, manage, auth)
    },
    onSuccess: (data) => {
      params.onSuccess?.(data)
      if (params.path) {
        invalidate(params.path)
      }
    },
    onError: (error) => {
      onAuthError(error)
      params?.onError?.(error)
    },
    ...params.options,
  })

  const isLoading = computed<boolean>(() => req.isPending.value)

  return {
    ...req,
    isLoading,
    mutate: req.mutate,
  }
}

export interface ICreateManyParams extends IDataProviderCreateManyOptions {
  providerName?: string
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderCreateManyOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
}

/**
 * Create data
 * @param params
 */
export function useCreateMany(params: ICreateManyParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()
  const { invalidate } = useInvalidate()
  const props = computed((): IDataProviderCreateManyOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useMutation({
    mutationFn: (data) => {
      if (!manage.config?.dataProvider) {
        throw new Error('Data provider is not initialized')
      }
      if (data.path) {
        params.path = data.path
      }
      return manage.config?.dataProvider?.[providerName]?.createMany({
        ...props.value,
        ...data,
      }, manage, auth)
    },
    onSuccess: (data) => {
      params.onSuccess?.(data)
      if (params.path) {
        invalidate(params.path)
      }
    },
    onError: (error) => {
      onAuthError(error)
      params?.onError?.(error)
    },
    ...params.options,
  })

  const isLoading = computed<boolean>(() => req.isPending.value)

  return {
    ...req,
    isLoading,
    mutate: req.mutate,
  }
}

export interface IUpdateParams extends IDataProviderUpdateOptions {
  providerName?: string
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderUpdateOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
}

/**
 * Update data
 * @param params
 */
export function useUpdate(params: IUpdateParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()
  const { invalidate } = useInvalidate()
  const props = computed((): IDataProviderUpdateOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useMutation({
    mutationFn: (data) => {
      if (!manage.config?.dataProvider) {
        throw new Error('Data provider is not initialized')
      }
      if (data.path) {
        params.path = data.path
      }
      return manage.config?.dataProvider?.[providerName]?.update({
        ...props.value,
        ...data,
      }, manage, auth)
    },
    onSuccess: (data) => {
      params.onSuccess?.(data)
      if (params.path) {
        invalidate(params.path)
      }
    },
    onError: (error) => {
      onAuthError(error)
      params?.onError?.(error)
    },
    ...params.options,
  })

  const isLoading = computed<boolean>(() => req.isPending.value)

  return {
    ...req,
    isLoading,
    mutate: req.mutate,
  }
}

export interface IUpdateManyParams extends IDataProviderUpdateManyOptions {
  providerName?: string
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderUpdateManyOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
}

export function useUpdateMany(params: IUpdateManyParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()
  const { invalidate } = useInvalidate()

  const props = computed((): IDataProviderUpdateManyOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useMutation({
    mutationFn: (data) => {
      if (!manage.config?.dataProvider) {
        throw new Error('Data provider is not initialized')
      }
      if (data.path) {
        params.path = data.path
      }
      return manage.config?.dataProvider?.[providerName]?.updateMany({
        ...props.value,
        ...data,
      }, manage, auth)
    },
    onSuccess: (data) => {
      params.onSuccess?.(data)
      if (params.path) {
        invalidate(params.path)
      }
    },
    onError: (error) => {
      onAuthError(error)
      params?.onError?.(error)
    },
    ...params.options,
  })

  const isLoading = computed<boolean>(() => req.isPending.value)

  return {
    ...req,
    isLoading,
    mutate: req.mutate,
  }
}

export interface IDeleteParams extends IDataProviderDeleteOptions {
  providerName?: string
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderDeleteOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
}

/**
 * Update data
 * @param params
 */
export function useDelete(params: IDeleteParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()
  const { invalidate } = useInvalidate()

  const props = computed((): IDataProviderDeleteOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useMutation({
    mutationFn: (data) => {
      if (!manage.config?.dataProvider) {
        throw new Error('Data provider is not initialized')
      }
      if (data.path) {
        params.path = data.path
      }
      return manage.config?.dataProvider?.[providerName]?.deleteOne({
        ...props.value,
        ...data,
      }, manage, auth)
    },
    onSuccess: (data) => {
      params.onSuccess?.(data)
      if (params.path) {
        invalidate(params.path)
      }
    },
    onError: (error) => {
      onAuthError(error)
      params?.onError?.(error)
    },
    ...params.options,
  })

  const isLoading = computed<boolean>(() => req.isPending.value)

  return {
    ...req,
    isLoading,
    mutate: req.mutate,
  }
}

export interface IDeleteManyParams extends IDataProviderDeleteManyOptions {
  providerName?: string
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderDeleteManyOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
}

/**
 * Update data
 * @param params
 */
export function useDeleteMany(params: IDeleteManyParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params.providerName || 'default'
  const { mutate: onAuthError } = useError()
  const { invalidate } = useInvalidate()
  const props = computed((): IDataProviderDeleteManyOptions => {
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useMutation({
    mutationFn: (data) => {
      if (!manage.config?.dataProvider) {
        throw new Error('Data provider is not initialized')
      }
      if (data.path) {
        params.path = data.path
      }
      return manage.config?.dataProvider?.[providerName]?.deleteMany({
        ...props.value,
        ...data,
      }, manage, auth)
    },
    onSuccess: (data) => {
      params.onSuccess?.(data)
      if (params.path) {
        invalidate(params.path)
      }
    },
    onError: (error) => {
      onAuthError(error)
      params?.onError?.(error)
    },
    ...params.options,
  })

  const isLoading = computed<boolean>(() => req.isPending.value)

  return {
    ...req,
    isLoading,
    mutate: req.mutate,
  }
}

export interface ICustomParams extends IDataProviderCustomOptions {
  providerName?: string
  options?: IDataQueryOptions
  onError?: (error: IDataProviderError) => void
}

/**
 * Custom query request
 * @param params
 */
export function useCustom(params?: ICustomParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params?.providerName || 'default'
  const { mutate: onAuthError } = useError()

  const props = computed((): IDataProviderCustomOptions => {
    if (!params) {
      return {}
    }
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useQuery({
    queryKey: [`${manage.config?.name}:${providerName}:${params?.path}`, props],
    queryFn: () => manage.config?.dataProvider?.[providerName]?.custom(props.value, manage, auth),
    ...params?.options,
  })

  const isLoading = computed<boolean>(() => {
    if (req.isFetched.value) {
      return false
    }
    return req.isFetching.value
  })

  watch(req.isError, (v) => {
    if (!v) {
      return
    }
    onAuthError(req.error.value as IDataProviderError)
    params?.onError?.(req.error.value as IDataProviderError)
  })

  const data = ref<IDataProviderResponse | undefined>(undefined)
  watch(req.data, (v) => {
    if (!v) {
      return
    }
    data.value = v
  }, {
    immediate: true,
  })

  return {
    ...req,
    isLoading,
    data,
    refetch: req.refetch,
  }
}

export interface ICustomMutationParams extends IDataProviderCustomOptions {
  providerName?: string
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderCustomOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
}

/**
 * Custom mutation request
 * @param params
 */
export function useCustomMutation(params?: ICustomMutationParams) {
  const manage = useManage()
  const auth = useGetAuth()
  const providerName = params?.providerName || 'default'
  const { mutate: onAuthError } = useError()

  const props = computed((): IDataProviderCustomOptions => {
    if (!params) {
      return {}
    }
    const { onError, options, ...rest } = params
    return rest
  })

  const req = useMutation({
    mutationFn: (data) => {
      if (!manage.config?.dataProvider) {
        throw new Error('Data provider is not initialized')
      }
      return manage.config?.dataProvider?.[providerName]?.custom({
        ...props.value,
        ...data,
      }, manage, auth)
    },
    onSuccess: (data) => {
      req.reset()
      params?.onSuccess?.(data)
    },
    onError: (error) => {
      onAuthError(error)
      params?.onError?.(error)
    },
    ...params?.options,
  })

  const isLoading = computed<boolean>(() => req.isPending.value)

  return {
    ...req,
    isLoading,
    mutate: req.mutate,
  }
}

interface IClientParams extends IDataProviderCustomOptions {
  providerName?: string
}

/**
 * Custom request client
 */
export function useClient() {
  const manage = useManage()
  const auth = useGetAuth()
  const request = (params: IClientParams) => {
    if (!manage.config?.dataProvider) {
      throw new Error('Data provider is not initialized')
    }
    const providerName = params.providerName || 'default'
    return manage.config?.dataProvider?.[providerName]?.custom({
      ...params,
    }, manage, auth) as Promise<IDataProviderResponse>
  }

  return {
    request,
  }
}

export function useInvalidate() {
  const queryClient = useQueryClient()
  const manage = useManage()

  const invalidate = (path: string, providerName?: string) => {
    let marks: any = path
    if (!Array.isArray(path)) {
      marks = [path]
    }

    for (const mark of marks) {
      const key = `${manage.config?.name}:${providerName || 'default'}:${mark}`
      queryClient.invalidateQueries({
        queryKey: [key],
      })
    }
  }

  return {
    invalidate,
  }
}



---
File: /packages/core/src/hooks/export.ts
---

import type { IDataProviderPagination, IDataProviderResponse } from '../types'
import type { IInfiniteListParams } from './data'
import { computed, ref } from 'vue'
import { useInfiniteList } from './data'

export interface IUseExportProps extends IInfiniteListParams {
  onSuccess?: (data?: IDataProviderResponse) => void
  onProgress?: (data?: IDataProviderPagination) => void
  interval?: number
  maxPage?: number | (() => number)
}

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

export function useExport(props: IUseExportProps) {
  const isExporting = ref(false)

  const listProps = computed(() => {
    const { onSuccess, onProgress, interval, maxPage, ...rest } = props
    return {
      ...rest,
      options: {
        ...rest.options,
        enabled: false,
        refetchOnMount: false,
        refetchOnWindowFocus: false,
        refetchOnReconnect: false,
      },
    }
  })

  const interval = computed(() => {
    return props.interval || 300
  })

  const { data, isLoading, fetchNextPage, hasNextPage, refetch, pagination } = useInfiniteList(listProps.value)

  const trigger = async () => {
    if (isExporting.value) {
      return
    }

    try {
      isExporting.value = true
      pagination.value.page = 1

      props.onProgress?.(pagination.value)

      await refetch()

      const max = typeof props.maxPage === 'function' ? props.maxPage() : (props.maxPage || 0)

      while (hasNextPage.value) {
        if (max > 0 && pagination.value.page >= max) {
          break
        }

        if (interval.value > 0) {
          await sleep(interval.value)
        }

        await fetchNextPage()

        props.onProgress?.(pagination.value)
      }
      props.onSuccess?.(data.value as any)
    }
    finally {
      isExporting.value = false
    }
  }

  const loading = computed(() => {
    return isLoading.value || isExporting.value
  })

  return {
    data,
    isLoading: loading,
    trigger,
  }
}



---
File: /packages/core/src/hooks/exportCsv.ts
---

import type { IUseExportProps } from './export'
import { json2csv } from 'json-2-csv'
import { computed } from 'vue'
import { useExport } from './export'

export interface IUseExportCsvProps extends IUseExportProps {
  filename?: string
  headers?: string[] | boolean
  csvOptions?: {
    delimiter?: string
    quote?: string | boolean
    escape?: string
    eol?: string
    writeBOM?: boolean
  }
}

export function useExportCsv(props: IUseExportCsvProps) {
  const exportProps = computed(() => {
    const { filename, headers, csvOptions, ...rest } = props
    return rest
  })

  const csvOptions = computed(() => {
    const options = props.csvOptions || {}
    const wrapChar = options.quote
    return {
      prependHeader: props.headers !== false,
      keys: Array.isArray(props.headers) ? props.headers : undefined,
      delimiter: {
        field: options.delimiter || ',',
        wrap: typeof wrapChar === 'string' ? wrapChar : '"',
        eol: options.eol || '\n',
      },
      excelBOM: options.writeBOM || false,
    }
  })

  const res = useExport({
    ...exportProps.value,
    onSuccess: async (res) => {
      if (!res?.data || !res?.data?.length) {
        props.onError?.({
          message: 'No data to export',
          status: 400,
        })
        return
      }

      try {
        const csvString = await json2csv(res.data, csvOptions.value)

        const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' })
        const url = URL.createObjectURL(blob)

        const link = document.createElement('a')
        link.href = url
        link.download = props.filename || 'export.csv'
        link.style.display = 'none'

        document.body.appendChild(link)
        link.click()

        document.body.removeChild(link)
        URL.revokeObjectURL(url)

        props.onSuccess?.(res)
      }
      catch (error) {
        props.onError?.({
          message: `CSV Export Error: ${error}`,
          status: 500,
        })
      }
    },
  })

  return res
}



---
File: /packages/core/src/hooks/form.ts
---

import type { MaybeRef } from 'vue'
import type { IDataProviderError, IDataProviderResponse } from '../types'
import { cloneDeep } from 'lodash-es'
import { computed, ref, toRef, watch } from 'vue'
import { useCreate, useOne, useUpdate } from './data'

type Key = string | number | undefined
export interface IUseFormProps {
  path?: string
  id?: MaybeRef<Key>
  form?: MaybeRef<Record<string, any>>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void
  action?: 'create' | 'edit'
  providerName?: string
}

export function useForm(props: IUseFormProps) {
  const form = toRef(props, 'form', {})
  const id = toRef(props, 'id', undefined)

  // 初始化数据，用于重置表单数据
  const editResetData = ref(cloneDeep(form.value || {}))
  // 首次初始化数据，用于创建时，设置表单数据
  const createResetData = ref(cloneDeep(form.value || {}))

  const isEdit = computed(() => {
    return props.action === 'edit' || !!id.value
  })

  const { data: oneData, isLoading: isLoadingOne, refetch } = useOne({
    get path() {
      return props.path || ''
    },
    get id() {
      return id.value as Key
    },
    options: {
      enabled: false,
    },
    providerName: props.providerName,
  })

  // 重置表单数据
  const onReset = () => {
    let resetData = {}
    if (isEdit.value) {
      resetData = cloneDeep(editResetData.value)
    }
    else {
      resetData = cloneDeep(createResetData.value)
    }
    Object.assign(form.value, resetData)
  }

  // 初始化表单数据
  watch([id, isEdit], async () => {
    if (!isEdit.value) {
      onReset()
      return
    }
    await refetch()
    const data = cloneDeep(oneData.value?.data || {})
    Object.assign(form.value as object, data)
    Object.assign(editResetData.value as object, data)
  }, {
    immediate: true,
    deep: true,
  })

  const create = useCreate({
    path: props.path ?? '',
    data: form.value,
    onSuccess: (data) => {
      onReset()
      props.onSuccess?.(data)
    },
    onError: (error) => {
      props.onError?.(error)
    },
    providerName: props.providerName,
  })

  const update = useUpdate({
    get path() {
      return props.path ?? ''
    },
    get id() {
      return id.value as Key
    },
    data: form.value,
    onSuccess: (data) => {
      props.onSuccess?.(data)
    },
    onError: (error) => {
      props.onError?.(error)
    },
    providerName: props.providerName,
  })

  const onSubmit = (data?: Record<string, any>) => {
    if (!isEdit.value) {
      create.mutate({
        data: data || form.value,
      })
    }
    else {
      update.mutate({
        id: id.value as Key,
        data: data || form.value,
      })
    }
  }

  const isLoading = computed<boolean>(() => isLoadingOne.value || create.isLoading.value || update.isLoading.value)

  return {
    form,
    initData: isEdit.value ? editResetData.value : createResetData.value,
    isLoading,
    isEdit,
    onSubmit,
    onReset,
  }
}



---
File: /packages/core/src/hooks/formExtend.ts
---

import type { TypedSchema } from 'vee-validate'
import type { IUseFormProps } from './form'
import { computed, toRef } from 'vue'
import { useForm } from './form'
import { useValidateForm } from './formValidate'

export interface UseExtendFormProps extends IUseFormProps {
  rules?: TypedSchema
}

export function useExtendForm(props: UseExtendFormProps) {
  const form = toRef(props, 'form', {})

  const { validate, reset: onResetValidate } = useValidateForm({
    data: form,
    rules: props.rules,
  })

  const formProps = computed(() => {
    const { form, ...rest } = props
    return {
      ...rest,
    }
  })

  const result = useForm({
    ...formProps.value,
    form: form.value,
  })

  const onSubmit = (data?: Record<string, any>) => {
    validate().then((v) => {
      if (!v.valid) {
        props.onError?.({
          message: '表单验证失败',
        })
        return
      }
      result.onSubmit(data)
    })
  }

  const onReset = () => {
    result.onReset()
    onResetValidate()
  }

  return {
    isLoading: result.isLoading,
    isEdit: result.isEdit,
    form,
    onSubmit,
    onReset,
  }
}



---
File: /packages/core/src/hooks/formValidate.ts
---

import type { TypedSchema } from 'vee-validate'
import type { MaybeRef } from 'vue'
import { all } from '@vee-validate/rules'
import { cloneDeep } from 'lodash-es'
import { defineRule, useForm } from 'vee-validate'
import { toRef, watch } from 'vue'

export interface UseValidateFormProps {
  data?: MaybeRef<Record<string, any>>
  rules?: TypedSchema
}

export function useValidateForm(props: UseValidateFormProps) {
  const data = toRef(props, 'data')

  const { setValues, validate, resetForm, handleSubmit } = useForm({
    initialValues: cloneDeep(data.value || {}),
    validationSchema: props.rules,
  })

  watch(data, (v) => {
    setValues(v || {}, false)
  }, { deep: true })

  const reset = () => {
    resetForm()
  }

  return {
    validate,
    reset,
    submit: handleSubmit,
  }
}

export function initFormValidate() {
  Object.entries(all).forEach(([name, rule]) => {
    defineRule(name, rule)
  })
}



---
File: /packages/core/src/hooks/i18n.ts
---

import { useI18nStore } from '../stores'
import { useManage } from './manage'

export function useI18n() {
  const i18nStore = useI18nStore()
  const manage = useManage()

  const t = (key: string, options?: any, defaultMessage?: string) => {
    return manage.config?.i18nProvider?.t(key, options, defaultMessage)
  }

  const changeLocale = (lang: string) => {
    i18nStore.setLocale(lang)
    return manage.config?.i18nProvider?.changeLocale(lang)
  }

  const getLocale = () => {
    return manage.config?.i18nProvider?.getLocale()
  }

  const loadLocale = (lang: string, messages: Record<string, unknown>) => {
    return manage.config?.i18nProvider?.loadLocale(lang, messages)
  }

  const mergeLocale = (lang: string, messages: Record<string, unknown>) => {
    return manage.config?.i18nProvider?.mergeLocale(lang, messages)
  }

  const getLocales = () => {
    return manage.config?.i18nProvider?.getLocales()
  }

  return {
    t,
    changeLocale,
    getLocale,
    loadLocale,
    mergeLocale,
    getLocales,
  }
}



---
File: /packages/core/src/hooks/import.ts
---

import type { DefaultError, UseMutationOptions } from '@tanstack/vue-query'
import type { IDataProviderCustomOptions, IDataProviderError, IDataProviderResponse } from '../types'
import { computed, ref } from 'vue'
import { useCustomMutation } from './data'

export interface IImportProgress {
  totalItems: number // 总条数
  processedItems: number // 处理条数
  totalBatches: number // 总批次
  processedBatches: number // 处理批次
  percentage: number // 百分比
}

export interface IUseImportProps extends IDataProviderCustomOptions {
  options?: UseMutationOptions<IDataProviderResponse, DefaultError, IDataProviderCustomOptions>
  onComplete?: (progress: IImportProgress) => void
  onProgress?: (progress: IImportProgress) => void
  onError?: (error: IDataProviderError) => void
  interval?: number
  chunkSize?: number
}

const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms))

export function useImport(props: IUseImportProps) {
  const isImporting = ref(false)

  const progress = ref<IImportProgress>({
    totalItems: 0,
    processedItems: 0,
    totalBatches: 0,
    processedBatches: 0,
    percentage: 0,
  })

  const params = computed(() => {
    const { onComplete, onProgress, onError, interval, chunkSize, ...rest } = props
    return rest
  })

  const { mutate: onImport } = useCustomMutation({
    path: props.path,
    method: 'POST',
    ...params.value,
    options: {
      ...params.value.options,
    },
  })

  const trigger = async (data: Record<string, any>[]) => {
    if (isImporting.value) {
      return
    }

    const chunkSize = props.chunkSize || 100
    const interval = props.interval || 100
    const totalItems = data.length
    const chunks: Record<string, any>[][] = []

    // 分批处理数据
    for (let i = 0; i < totalItems; i += chunkSize) {
      chunks.push(data.slice(i, i + chunkSize))
    }

    const totalBatches = chunks.length

    // 初始化进度
    progress.value = {
      totalItems,
      processedItems: 0,
      totalBatches,
      processedBatches: 0,
      percentage: 0,
    }

    isImporting.value = true

    try {
      for (let i = 0; i < chunks.length; i++) {
        const chunk = chunks[i]

        await onImport({
          payload: chunk,
        })

        progress.value.processedBatches = i + 1
        progress.value.processedItems += chunk.length
        progress.value.percentage = Math.round((progress.value.processedItems / totalItems) * 100)

        props.onProgress?.(progress.value)

        if (i < chunks.length - 1) {
          await sleep(interval)
        }
      }

      isImporting.value = false
      props.onComplete?.(progress.value)
    }
    catch (error) {
      isImporting.value = false
      props.onError?.(error as IDataProviderError)
    }
  }

  const loading = computed(() => isImporting.value)

  return {
    isLoading: loading,
    progress: computed(() => progress.value),
    trigger,
  }
}



---
File: /packages/core/src/hooks/importCsv.ts
---

import type { IUseImportProps } from './import'
import { useFileDialog } from '@vueuse/core'
import { csv2json } from 'json-2-csv'
import { computed } from 'vue'
import { useImport } from './import'

export interface IUseImportCsvProps extends IUseImportProps {
  csvOptions?: {
    delimiter?: string
    wrap?: string
    eol?: string
    excelBOM?: boolean
    headerFields?: string[]
    keys?: string[]
    trimHeaderFields?: boolean
    trimFieldValues?: boolean
  }
}

export function useImportCsv(props: IUseImportCsvProps) {
  const importProps = computed(() => {
    const { csvOptions, ...rest } = props
    return rest
  })

  const csvOptions = computed(() => {
    const options = props.csvOptions || {}
    return {
      delimiter: {
        field: options.delimiter || ',',
        wrap: options.wrap || '"',
        eol: options.eol || '\n',
      },
      excelBOM: options.excelBOM || false,
      headerFields: options.headerFields,
      keys: options.keys,
      trimHeaderFields: options.trimHeaderFields || false,
      trimFieldValues: options.trimFieldValues || false,
    }
  })

  const res = useImport({
    ...importProps.value,
  })

  // 读取文件
  const readFile = async (file: File) => {
    try {
      const text = await file.text()

      const jsonData = await csv2json(text, csvOptions.value)

      if (jsonData && jsonData.length > 0) {
        // 调用导入触发器
        await res.trigger(jsonData)
      }
      else {
        props.onError?.({
          message: 'CSV 文件为空或格式不正确',
          status: 400,
        })
      }
    }
    catch (error) {
      props.onError?.({
        message: `CSV 解析错误: ${error}`,
        status: 500,
      })
    }
  }

  const { open: openFileDialog, reset, onChange } = useFileDialog({
    accept: '.csv',
    multiple: false,
  })

  onChange((selectedFiles) => {
    if (selectedFiles && selectedFiles.length > 0) {
      readFile(selectedFiles[0])
    }
  })

  const open = () => {
    reset()
    openFileDialog()
  }

  return {
    ...res,
    open,
    readFile,
  }
}



---
File: /packages/core/src/hooks/index.ts
---

export * from '../config/color'
export * from './auth'
export * from './config'
export * from './data'
export * from './export'
export * from './exportCsv'
export * from './form'
export * from './formExtend'
export * from './formValidate'
export * from './i18n'
export * from './import'
export * from './importCsv'
export * from './json'
export * from './json/index'
export * from './list'
export * from './manage'
export * from './menu'
export * from './overlay'
export * from './select'
export * from './theme'
export * from './tree'
export * from './upload'
export * from './upload/index'



---
File: /packages/core/src/hooks/json.tsx
---

import type { Component, Ref } from 'vue'
import type { IConfig } from '../types'
import type { JsonAdaptorOptions, JsonSchemaNode } from './json/index'
import { computed, defineComponent, h, isRef, markRaw, unref } from 'vue'
import { useJsonSchemaStore } from '../stores/jsonSchema'
import { useConfig } from './config'
import { defaultAdaptors } from './json/index'
import { injectContext } from './json/utils/contextManager'

function kebabCase(str: string): string {
  return str
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .toLowerCase()
}

/**
 * 加载组件到 store
 */
function loadComponentsToStore(components: Record<string, Component> | Component[], jsonSchemaStore: any) {
  if (Array.isArray(components)) {
    components.forEach((component) => {
      const comp = component as any
      let name = comp.name
      if (!name && comp.__name) {
        name = comp.__name.replace(/\.(vue|ts|tsx|js|jsx)$/, '').split('/').pop()
      }
      if (name) {
        jsonSchemaStore.addComponent(markRaw(component), name)
      }
    })
  }
  else if (typeof components === 'object' && components !== null) {
    Object.entries(components).forEach(([name, component]) => {
      jsonSchemaStore.addComponent(markRaw(component), name)
    })
  }
}

/**
 * 初始化 JSON Schema 组件
 * 在应用启动时调用，将配置中的组件加载到全局缓存
 */
export function initJsonSchemaComponents(config: IConfig, manageName?: string) {
  const jsonSchemaStore = useJsonSchemaStore(manageName)

  if (config.jsonSchema?.components) {
    loadComponentsToStore(config.jsonSchema.components, jsonSchemaStore)
  }

  config.manages?.forEach((manage) => {
    if (manage.jsonSchema?.components) {
      loadComponentsToStore(manage.jsonSchema.components, jsonSchemaStore)
    }
  })
}

export type JsonSchemaData = JsonSchemaNode[] | Ref<JsonSchemaNode[]>

export interface UseJsonSchemaProps extends JsonAdaptorOptions {
  data?: JsonSchemaData
  components?: Record<string, Component> | Component[]
  context?: Record<string, any> | Ref<Record<string, any>>
}

/**
 * JSON Schema 渲染器
 */
export function useJsonSchema(props?: UseJsonSchemaProps) {
  const config = useConfig()
  const jsonSchemaStore = useJsonSchemaStore()

  const adaptors = [
    ...defaultAdaptors,
    ...(config.jsonSchema?.adaptors || []),
    ...(props?.adaptors || []),
  ]

  if (props?.components) {
    loadComponentsToStore(props.components, jsonSchemaStore)
  }
  const data = computed(() => {
    return isRef(props?.data) ? props?.data.value : props?.data
  })

  function getGlobalContext(): Record<string, any> {
    const ctx = isRef(props?.context) ? props?.context.value : props?.context
    return ctx || {}
  }

  /**
   * 处理节点属性，解包响应式数据
   */
  function processProps(nodeProps: Record<string, any>): Record<string, any> {
    const processedProps: Record<string, any> = {}

    Object.entries(nodeProps).forEach(([key, value]) => {
      if (key === '_context')
        return

      const isModelProp = key === 'modelValue' || key.startsWith('modelValue')
        || (key !== 'value' && (key.includes('model') || key.includes('Model')))

      processedProps[key] = isModelProp && isRef(value) ? unref(value) : value
    })

    return processedProps
  }

  /**
   * 处理插槽内容
   */
  function processSlotContent(slotContent: any, slotProps: any, context: Record<string, any>): any {
    if (typeof slotContent === 'string')
      return slotContent
    if (typeof slotContent === 'function')
      return processSlotContent(slotContent(slotProps), slotProps, context)
    if (Array.isArray(slotContent))
      return slotContent.flatMap(item => processSlotContent(item, slotProps, context)).filter(Boolean)
    if (slotContent?.tag) {
      // 将插槽参数注入到上下文中
      const slotContext = { ...context, ...slotProps }
      return processNode(slotContent, true, slotContext)
    }
    return slotContent
  }

  /**
   * 处理子元素
   */
  function processChildren(children: any, isSlotContent: boolean, context: Record<string, any>): any {
    if (!children)
      return undefined
    if (typeof children === 'string')
      return children
    if (Array.isArray(children)) {
      return children.flatMap((child) => {
        if (typeof child === 'string')
          return child
        return processNode(child, isSlotContent, context)
      }).filter(Boolean)
    }
    return processNode(children, isSlotContent, context)
  }

  /**
   * 处理单个节点
   */
  function processNode(schema: JsonSchemaNode, isSlotContent = false, parentContext: Record<string, any> = {}): any {
    const { tag, attrs = {}, children, slots } = schema

    const mergedContext = { ...getGlobalContext(), ...parentContext }

    let nodeProps = { ...attrs }
    if (Object.keys(mergedContext).length > 0) {
      nodeProps = { ...nodeProps, ...injectContext({}, mergedContext) }
    }

    for (const adaptor of adaptors) {
      const result = adaptor.process(schema, nodeProps)
      if (!result)
        continue

      nodeProps = result.props
      if (result.skip)
        return null
      if (result.nodes) {
        return result.nodes.map((node) => {
          const nodeContext = node.attrs?._context || {}
          return processNode(node, isSlotContent, { ...mergedContext, ...nodeContext })
        }).filter(Boolean)
      }
    }

    const resolveComponent = (tagName: string) => {
      // 直接从 store 中查找组件
      let component = jsonSchemaStore.getComponentByName(tagName)
      if (component) {
        return component
      }

      // 尝试 kebab-case 格式查找
      const kebabName = kebabCase(tagName)
      component = jsonSchemaStore.getComponentByName(kebabName)
      if (component) {
        return component
      }

      // 尝试 PascalCase 格式查找
      const pascalName = tagName.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase())
        .replace(/^[a-z]/, letter => letter.toUpperCase())
      component = jsonSchemaStore.getComponentByName(pascalName)
      if (component) {
        return component
      }

      return null
    }

    let resolvedTag = typeof tag === 'string' ? (resolveComponent(tag) || tag) : tag

    if (typeof resolvedTag !== 'string' && typeof resolvedTag === 'object') {
      resolvedTag = markRaw(resolvedTag)
    }

    const isVueComponent = typeof resolvedTag !== 'string'
    const processedProps = processProps(nodeProps)

    if (slots && isVueComponent && !isSlotContent) {
      const slotFunctions: Record<string, any> = {}
      Object.entries(slots).forEach(([slotName, slotContent]) => {
        slotFunctions[slotName] = (slotProps: any = {}) => processSlotContent(slotContent, slotProps, mergedContext)
      })
      return h(resolvedTag, processedProps, slotFunctions)
    }

    const processedChildren = processChildren(children, isSlotContent, mergedContext)

    if (isVueComponent && processedChildren !== undefined) {
      return h(resolvedTag, processedProps, { default: () => processedChildren })
    }

    return h(resolvedTag, processedProps, processedChildren)
  }

  const render = defineComponent({
    name: 'JsonSchemaRenderer',
    render() {
      return data.value?.map(node => processNode(node)).filter(Boolean) || []
    },
  })

  function renderAsync(options: {
    data: JsonSchemaNode[]
    context?: Record<string, any>
  }) {
    return defineComponent({
      name: 'DynamicJsonSchemaRenderer',
      render() {
        const dynamicContext = { ...getGlobalContext(), ...options.context }
        return options.data?.map(node => processNode(node, false, dynamicContext)).filter(Boolean)
      },
    })
  }

  return { render, renderAsync }
}



---
File: /packages/core/src/hooks/list.tsx
---

import type { IDataProviderError, IDataProviderPagination, IDataProviderResponse } from '../types'
import type { IImportProgress } from './import'
import { reactiveComputed, useCountdown } from '@vueuse/core'
import { computed, ref, toRef, watch } from 'vue'
import { useList } from './data'
import { useExportCsv } from './exportCsv'
import { useImportCsv } from './importCsv'

type IListKey = string | number

export interface IListPagination {
  page: number
  pageSize: number
}

export interface UseExtendListProps {
  path: string
  key?: IListKey
  totalField?: string
  filters?: Record<string, any>
  sorters?: Record<string, 'asc' | 'desc'>
  pagination?: boolean | IListPagination
  exportFilename?: string
  exportMaxPage?: number
  total?: (data?: IDataProviderResponse) => number
  onExportSuccess?: (data?: IDataProviderResponse) => void
  onExportProgress?: (data?: IDataProviderPagination) => void
  onExportError?: (error?: IDataProviderError) => void
  onImportSuccess?: (progress?: IImportProgress) => void
  onImportProgress?: (progress?: IImportProgress) => void
  onImportError?: (error?: IDataProviderError) => void
}

export function useExtendList(props: UseExtendListProps) {
  const filters = toRef(props, 'filters', {})
  const sorters = toRef(props, 'sorters', {})

  // 分页处理
  const pagination = toRef(typeof props.pagination === 'object'
    ? props.pagination
    : {
        page: 1,
        pageSize: 20,
      })

  const standardSizes = [10, 20, 30, 40, 50, 100]

  const generatePageSizes = (pageSize: number) => {
    return standardSizes.includes(pageSize)
      ? standardSizes
      : Array.from({ length: 5 }, (_, i) => pageSize * (i + 1))
  }

  const currentPageSizes = ref<number[]>(generatePageSizes(pagination.value.pageSize))

  watch(() => pagination.value.pageSize, (newPageSize) => {
    if (!currentPageSizes.value.includes(newPageSize)) {
      currentPageSizes.value = generatePageSizes(newPageSize)
    }
  })

  const onUpdatePageSize = (v) => {
    pagination.value.pageSize = v
    pagination.value.page = 1
  }

  const onUpdatePage = (v) => {
    pagination.value.page = v
  }

  // 数据处理
  const { data, isLoading, refetch } = useList({
    path: props.path,
    pagination: props.pagination ? pagination.value : false,
    filters: filters.value,
    sorters: sorters.value,
  })

  const list = computed<Record<string, any>[]>(() => data.value?.data || [])
  const meta = computed<Record<string, any> | undefined>(() => data.value?.meta || {})

  const total = computed(() => {
    return props.total?.(data.value) || meta.value?.[props.totalField || 'total'] || 0
  })

  const pageCount = computed(() => Math.ceil(total.value / pagination.value.pageSize) || 0)

  const onUpdateFilters = (v: Record<string, any>) => {
    filters.value = v
  }

  const onUpdateSorters = (v: Record<string, 'asc' | 'desc'>) => {
    sorters.value = v
  }

  // 选中处理
  const checkeds = ref<IListKey[]>([])

  const isAllChecked = computed(() => {
    return checkeds.value.length > 0 && checkeds.value.length === data.value?.data?.length
  })

  const isIndeterminate = computed(() => {
    return checkeds.value.length > 0 && checkeds.value.length < (data.value?.data?.length || 0)
  })

  const toggleChecked = (id: string | number) => {
    const index = checkeds.value.indexOf(id)
    if (index > -1) {
      checkeds.value.splice(index, 1)
    }
    else {
      checkeds.value.push(id)
    }
  }

  const onUpdateChecked = (v: IListKey[]) => {
    checkeds.value = v
  }

  const isChecked = (id: string | number) => {
    return checkeds.value.includes(id)
  }

  const toggleSelectAll = () => {
    if (isAllChecked.value) {
      checkeds.value = []
    }
    else {
      checkeds.value = data.value?.data?.map(item => item[props.key || 'id']).filter(id => id != null) || []
    }
  }

  watch(() => data.value?.data, () => {
    checkeds.value = []
  })

  // 刷新处理
  const onRefresh = () => {
    checkeds.value = []
    refetch()
  }

  // 导出处理
  const exportPagination = ref({
    page: 1,
    pageSize: 100,
  })

  const { trigger: onExport, isLoading: isExporting } = useExportCsv({
    path: props.path,
    filters: filters.value || {},
    sorters: sorters.value || {},
    maxPage: () => {
      return props.exportMaxPage || 0
    },
    pagination: exportPagination.value,
    filename: props.exportFilename || 'data.csv',
    onSuccess: (data) => {
      props.onExportSuccess?.(data)
      exportPagination.value.page = 1
    },
    onProgress: (v) => {
      props.onExportProgress?.(v)
    },
    onError: (error) => {
      props.onExportError?.(error)
      exportPagination.value.page = 1
    },
  })

  // 导出指定数据
  const exportFilter = reactiveComputed(() => {
    return {
      ids: checkeds.value,
    }
  })

  const { trigger: onExportRows, isLoading: isExportingRows } = useExportCsv({
    path: props.path,
    filters: exportFilter,
    maxPage: 1,
    filename: props.exportFilename || 'rows.csv',
    onSuccess: (data) => {
      props.onExportSuccess?.(data)
    },
    onError: (error) => {
      props.onExportError?.(error)
    },
  })

  // 导入处理
  const { open: onImport, isLoading: isImporting } = useImportCsv({
    path: props.path,
    onComplete: (progress) => {
      props.onImportSuccess?.(progress)
    },
    onProgress: (v) => {
      props.onImportProgress?.(v)
    },
    onError: (error) => {
      props.onImportError?.(error)
    },
  })

  // 自动刷新处理
  const autoRefetch = ref(false)
  const { remaining, start, stop } = useCountdown(10, {
    onComplete: () => {
      onRefresh()
      start()
    },
  })

  const onAutoRefetch = () => {
    autoRefetch.value = !autoRefetch.value
    if (autoRefetch.value) {
      onRefresh()
      start()
    }
    else {
      stop()
    }
  }

  return {
    // 数据
    list,
    meta,
    isLoading,
    pagination,
    filters,
    sorters,
    onRefresh,
    onUpdateFilters,
    onUpdateSorters,

    // 选中
    checkeds,
    isAllChecked,
    isIndeterminate,
    toggleChecked,
    isChecked,
    toggleSelectAll,
    onUpdateChecked,

    // 分页
    total,
    page: computed(() => pagination.value.page),
    pageSize: computed(() => pagination.value.pageSize),
    pageSizes: currentPageSizes.value,
    pageCount,
    onUpdatePage,
    onUpdatePageSize,

    // 导出
    onExport,
    isExporting,
    onExportRows,
    isExportingRows,

    // 导入
    onImport,
    isImporting,

    // 自动刷新
    autoRefetch,
    onAutoRefetch,
    autoCountdown: remaining,
  }
}



---
File: /packages/core/src/hooks/manage.ts
---

import type { Ref } from 'vue'
import type { IManage } from '../types'
import { trimStart } from 'lodash-es'
import { inject } from 'vue'
import { useRoute } from 'vue-router'
import { useManageStore } from '../stores'

export interface IManageHook {
  config: IManage
  getRoutePath: (path?: string) => string
  getApiUrl: (path?: string, dataProviderName?: string) => string
  getPath: () => string
}

/**
 * Manage
 * get manage config
 * @param name Manage name
 * @returns Manage
 */
export function useManage(name?: string): IManageHook {
  const manageRef = inject<Ref<string>>('dux.manage')
  if (!name) {
    name = manageRef?.value
  }
  if (!name) {
    throw new Error('manage name is not defined')
  }

  const { config: manage } = useManageStore(name)

  const getRoutePath = (path?: string) => {
    return `${manage?.routePrefix}/${trimStart(path || '', '/')}`
  }

  const getApiUrl = (path?: string, dataProviderName?: string) => {
    const dataProvider = manage?.dataProvider?.[dataProviderName || 'default']
    return dataProvider?.apiUrl?.(path, manage?.apiBasePath) || ''
  }

  const route = useRoute()
  const getPath = () => {
    const fullPath = route.path
    const prefix = manage?.routePrefix || ''
    return trimStart(fullPath.replace(prefix, ''), '/')
  }

  return {
    config: manage as IManage,
    getRoutePath,
    getApiUrl,
    getPath,
  }
}



---
File: /packages/core/src/hooks/menu.ts
---

import type { IMenu } from '../types'
import { cloneDeep } from 'lodash-es'
import { storeToRefs } from 'pinia'
import { computed, ref, watch } from 'vue'
import { useRoute } from 'vue-router'
import { useRouteStore } from '../stores'
import { arrayToTree, searchTree } from '../utils'

export interface UseMenuProps {
  doubleMenu?: boolean
}

export function useMenu(props?: UseMenuProps) {
  const routeStore = useRouteStore()
  const { routes } = storeToRefs(routeStore)

  const getMenu = (hidden: boolean = true): IMenu[] => {
    return cloneDeep(routes.value)?.filter(item => !!item?.name).filter(item => !hidden || item.hidden === undefined || item.hidden === false)
  }

  const originalList = computed<Record<string, any>[]>(() => {
    const menus = getMenu(false)
    return arrayToTree(menus, {
      idKey: 'name',
      parentKey: 'parent',
      childrenKey: 'children',
      sortKey: 'sort',
    }, undefined)
  })

  const list = computed<Record<string, any>[]>(() => {
    const menus = getMenu()
    const data = arrayToTree(menus, {
      idKey: 'name',
      parentKey: 'parent',
      childrenKey: 'children',
      sortKey: 'sort',
    }, undefined)
    return data
  })

  const route = useRoute()

  const allKey = ref(route.name)
  const appKey = ref(route.name)
  const subKey = ref(route.name)

  const mainMenu = computed(() => {
    if (props?.doubleMenu) {
      return list.value
    }
    const appList = cloneDeep(list.value)
    return appList?.map((item) => {
      delete item.children
      return item
    })
  })

  const subMenu = computed(() => {
    if (props?.doubleMenu) {
      return []
    }
    const subList = list.value?.find(item => item.name === appKey.value)?.children
    return subList || []
  })

  const crumbs = computed(() => {
    const data = searchTree(originalList.value, (item) => {
      return item?.name === route.name
    })
    return data
  })

  watch(() => props?.doubleMenu, () => {
    if (!props?.doubleMenu) {
      const paths = searchTree(list.value, (item) => {
        return item?.name === subKey.value
      })
      appKey.value = paths?.[paths.length - 1]?.name
      subKey.value = paths?.[paths.length - 1]?.name
    }
    else {
      const paths = searchTree(list.value, (item) => {
        return item?.name === appKey.value
      })

      appKey.value = paths?.[0]?.name
      subKey.value = paths?.[paths.length - 1]?.name
    }
  }, { immediate: true })

  const isSubMenu = computed(() => {
    if (!props?.doubleMenu) {
      return true
    }
    return (props?.doubleMenu || subMenu.value.length > 0)
  })

  watch([route, originalList, () => props?.doubleMenu], () => {
    const paths = searchTree(originalList.value, (item) => {
      return item.name === route.name
    })

    const findIndex = (list) => {
      let index = -1
      for (let i = list.length - 1; i >= 0; i--) {
        if (list[i].hidden === false || list[i].hidden === undefined) {
          index = i
          break
        }
      }
      return index
    }

    const subIndex = findIndex(paths)

    allKey.value = paths?.[subIndex]?.name

    if (props?.doubleMenu) {
      appKey.value = paths?.[subIndex]?.name
      subKey.value = paths?.[subIndex]?.name
    }
    else {
      appKey.value = paths?.[0]?.name
      subKey.value = paths?.[subIndex]?.name
    }
  }, { immediate: true })

  return {
    data: list,
    originalData: originalList,
    getMenu,
    mainMenu,
    subMenu,
    isSubMenu,
    crumbs,
    active: allKey,
    appActive: appKey,
    subActive: subKey,
  }
}



---
File: /packages/core/src/hooks/overlay.ts
---

import { useOverlayInject } from '@overlastic/vue'
import { DuxOverlay } from '../components'

export interface UseOverlayProps {
  component?: () => any
  componentProps?: Record<string, any>
  mask?: boolean
  maskClosable?: boolean
  duration?: number
  zIndex?: number
}

export function useOverlay(): {
  show: (props: UseOverlayProps) => any
} {
  const create = useOverlayInject(DuxOverlay)

  const show = (props: UseOverlayProps) => {
    return create(props)
  }

  return {
    show,
  }
}



---
File: /packages/core/src/hooks/select.ts
---

import { debounce, isArray } from 'lodash-es'
import { computed, ref, watch } from 'vue'
import { useList, useMany } from './data'

type SelectValue = Array<string | number> | string | number | null | undefined

export interface IUseSelectProps {
  /** 默认选中值，可以是单个值或数组 */
  defaultValue?: SelectValue
  /** 数据请求路径 */
  path?: string
  /** 请求参数 */
  params?: Record<string, any>
  /** 分页配置，false表示不分页，true表示默认20条/页，数字表示指定每页条数 */
  pagination?: boolean | number
  /** 数据提供者名称 */
  providerName?: string
  /**
   * 选项显示标签配置
   * - 字符串：指定用作显示标签的字段名
   * - 函数：自定义标签生成逻辑
   * - 默认fallback顺序：label -> name -> title -> value/id的字符串形式
   */
  optionLabel?: string | ((item: Record<string, any>) => string)
  /**
   * 选项值配置
   * - 字符串：指定用作选项值的字段名
   * - 函数：自定义值获取逻辑
   * - 默认fallback顺序：value -> id
   * - 用途：生成最终选项的 value 属性，供外部使用
   */
  optionValue?: string | ((item: Record<string, any>) => string)
  /**
   * 选项唯一标识字段名
   * - 仅支持字符串类型，指定用于去重比较的字段名
   * - 默认fallback顺序：value -> id
   * - 用途：内部选项去重和比较，防止重复选项
   * - 与 optionValue 的区别：optionField 用于内部去重逻辑，optionValue 用于生成最终选项值
   */
  optionField?: string
  /** 搜索关键词字段名，默认为 'keyword' */
  keywordField?: string
  /** 搜索防抖延迟时间（毫秒），默认300ms */
  debounce?: number
}

export function useSelect(props: IUseSelectProps) {
  const keyword = ref<string>()
  const pagination = ref({
    page: 1,
    pageSize: typeof props.pagination === 'number'
      ? props.pagination
      : props.pagination ? 20 : 0,
  })
  const selectedOnce = ref(false)

  const debouncedSearch = debounce((value: string) => {
    keyword.value = value
  }, props.debounce || 300)

  const onSearch = (searchValue: string) => {
    debouncedSearch(searchValue)
  }

  const { data, isLoading, total, pageCount } = useList({
    get path() {
      return props.path || ''
    },
    get filters() {
      const filters: Record<string, any> = { ...props.params }
      if (keyword.value) {
        filters[props.keywordField || 'keyword'] = keyword.value
      }
      return filters
    },
    get pagination() {
      return props.pagination ? pagination.value : undefined
    },
    get providerName() {
      return props.providerName
    },
  })

  const selectedItems = ref<Record<string, any>[]>([])

  const getOptionFieldValue = (item: Record<string, any>) => {
    const fieldConfig = props.optionField || props.optionValue

    if (typeof fieldConfig === 'string') {
      return item[fieldConfig] || item.value || item.id
    }
    else if (typeof fieldConfig === 'function') {
      return fieldConfig(item)
    }
    return item.value || item.id
  }

  const formatOption = (item: Record<string, any>) => {
    const { optionLabel = 'label', optionValue = 'value' } = props

    let label: string
    if (typeof optionLabel === 'function') {
      label = optionLabel(item)
    }
    else if (typeof optionLabel === 'string') {
      label = item[optionLabel] || item.label || item.name || item.title || String(item.value || item.id || '')
    }
    else {
      label = item.label || item.name || item.title || String(item.value || item.id || '')
    }

    let value: string | number
    if (typeof optionValue === 'function') {
      value = optionValue(item)
    }
    else if (typeof optionValue === 'string') {
      value = item[optionValue] || item.value || item.id
    }
    else {
      value = item.value || item.id
    }

    return {
      label,
      value,
      raw: item,
    }
  }

  const options = computed(() => {
    const listData = data.value?.data || []

    const combined = [...selectedItems.value]
    listData.forEach((item) => {
      const exists = combined.some(selected =>
        getOptionFieldValue(selected) === getOptionFieldValue(item),
      )
      if (!exists) {
        combined.push(item)
      }
    })

    return combined.map(item => formatOption(item))
  })

  const meta = computed(() => data.value?.meta || {})

  const { refetch: fetchSelected } = useMany({
    get path() {
      return props.path || ''
    },
    get ids() {
      if (!props.defaultValue) {
        return []
      }
      return isArray(props.defaultValue) ? props.defaultValue as string[] : [props.defaultValue as string]
    },
    options: {
      enabled: false,
    },
    providerName: props.providerName,
  })

  watch(() => props.defaultValue, async (value) => {
    if (selectedOnce.value || !value) {
      return
    }
    selectedOnce.value = true

    const defaultValues = Array.isArray(value) ? value : [value]

    const allValuesExist = defaultValues.every(val =>
      options.value.some(option => option.value === val),
    )

    if (allValuesExist) {
      return
    }

    try {
      const res = await fetchSelected()
      selectedItems.value = res?.data?.data || []
    }
    catch (error) {
      console.warn('Failed to fetch selected items:', error)
    }
  }, { immediate: true })

  const loading = computed(() => isLoading.value)

  return {
    onSearch,
    options,
    meta,
    loading,
    pagination,
    total,
    pageCount,
  }
}



---
File: /packages/core/src/hooks/theme.ts
---

import type { ITheme } from '../types'
import { useColorMode, useCycleList } from '@vueuse/core'
import { hex2rgb } from 'colorizr'
import { storeToRefs } from 'pinia'
import { computed, readonly, watch, watchEffect } from 'vue'
import { themeColor } from '../config'
import { useThemeStore } from '../stores'
import { useManage } from './manage'

// 色彩类型定义
export type ThemeColorType = 'primary' | 'info' | 'success' | 'warning' | 'error' | 'gray'
export type ThemeColorName = string
export type ThemeColorShade = '50' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900' | '950'

// 场景类型定义 - 更精确的类型
export type ThemeSceneType = 'default' | 'hover' | 'pressed' | 'focus' | 'disabled'

// 色彩场景配置
export interface ThemeColorSceneConfig {
  default: string // 默认色阶，对应 --ui-primary 不带后缀的变量
  hover: string
  pressed: string
  focus: string
  disabled: string
}

// 色彩场景组配置
export interface ThemeColorSceneGroupConfig {
  default: ThemeColorSceneConfig
  overrides?: Partial<Record<ThemeColorType, Partial<ThemeColorSceneConfig>>>
}

// 语义变量配置
export interface ThemeColorSemanticConfig {
  text: {
    dimmed: string
    muted: string
    toned: string
    base: string
    highlighted: string
    inverted: string
  }
  bg: {
    base: string
    muted: string
    elevated: string
    accented: string
    inverted: string
  }
  border: {
    base: string
    muted: string
    accented: string
    inverted: string
  }
}

// 主题配置
export interface ThemeConfig {
  colors: Record<string, Record<string, string>>
  colorTypes: ThemeColorType[]
  colorShades: ThemeColorShade[]
  colorScenes: {
    light: ThemeColorSceneGroupConfig
    dark: ThemeColorSceneGroupConfig
  }
  colorSemantic: {
    light: ThemeColorSemanticConfig
    dark: ThemeColorSemanticConfig
  }
  colorBase?: {
    white: string
    black: string
  }
}

export function useTheme() {
  const themeStore = useThemeStore()

  const { mode } = storeToRefs(themeStore)
  const colorMode = useColorMode({
    storageRef: mode,
  })
  const manage = useManage()

  const { state, next, go } = useCycleList(['dark', 'light', 'auto'] as const, {
    initialValue: colorMode.store.value,
  })

  watchEffect(() => {
    colorMode.value = state.value
  })

  const setMode = (mode: 'dark' | 'light' | 'auto') => {
    switch (mode) {
      case 'auto':
        go(2)
        break
      case 'light':
        go(1)
        break
      case 'dark':
        go(0)
        break
    }
  }

  const isDark = computed(() => {
    const { system, store } = colorMode
    if (store.value === 'auto') {
      return system.value === 'dark'
    }
    return store.value === 'dark'
  })

  const resources = computed<ITheme>(() => {
    if (isDark.value) {
      return {
        logo: manage.config?.theme?.darkLogo,
        banner: manage.config?.theme?.darkBanner,
      }
    }
    return {
      logo: manage.config?.theme?.logo,
      banner: manage.config?.theme?.banner,
    }
  })

  const defaultConfig: ThemeConfig = {
    colors: themeColor,
    // 色彩类型
    colorTypes: ['primary', 'info', 'success', 'warning', 'error', 'gray'],
    // 色彩色阶
    colorShades: ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950'],
    // 色彩场景
    colorScenes: {
      light: {
        default: { default: '600', hover: '600', pressed: '700', focus: '500', disabled: '300' },
      },
      dark: {
        default: { default: '500', hover: '400', pressed: '300', focus: '500', disabled: '600' },
      },
    },
    // 语义颜色
    colorSemantic: {
      light: {
        text: { dimmed: '300', muted: '400', toned: '600', base: '800', highlighted: '900', inverted: 'white' },
        bg: { base: 'white', muted: '50', elevated: '100', accented: '200', inverted: '900' },
        border: { base: '100', muted: '200', accented: '300', inverted: '900' },
      },
      dark: {
        text: { dimmed: '600', muted: '500', toned: '300', base: '400', highlighted: '100', inverted: 'black' },
        bg: { base: '950', muted: '900', elevated: '800', accented: '700', inverted: '100' },
        border: { base: '900', muted: '800', accented: '700', inverted: '100' },
      },
    },
    colorBase: { white: '#ffffff', black: '#000000' },
  }

  // 合并配置
  const finalConfig = { ...defaultConfig, ...manage.config?.theme?.config }
  const { colorShades, colorTypes } = finalConfig

  // 使用store中的色彩映射
  const colorMapping = computed(() => themeStore.theme)

  // 获取所有可用的色彩名称
  const colors = computed(() => Object.keys(finalConfig.colors) as ThemeColorName[])

  // 色彩场景
  const colorScenes: ThemeSceneType[] = ['default', 'hover', 'pressed', 'focus', 'disabled']

  // 获取当前主题配置的辅助函数
  function getCurrentThemeConfig() {
    return isDark.value ? finalConfig.colorScenes.dark : finalConfig.colorScenes.light
  }

  // 专门获取色阶编号
  function getColorLevel(type: ThemeColorType, scene: ThemeSceneType): ThemeColorShade {
    const currentSceneGroup = getCurrentThemeConfig()
    const defaultScenes = currentSceneGroup.default

    // 如果指定了颜色类型，尝试获取特定配置
    if (currentSceneGroup.overrides?.[type]) {
      const typeSpecificScenes = currentSceneGroup.overrides[type]
      const sceneValue = typeSpecificScenes?.[scene]
      if (sceneValue) {
        return sceneValue as ThemeColorShade
      }
    }

    // 使用默认配置
    return (defaultScenes[scene] || '500') as ThemeColorShade
  }

  // 专门获取最终颜色值
  function getColorValue(type: ThemeColorType, level: ThemeColorShade): string {
    const mappedColor = colorMapping.value[type]
    return finalConfig.colors[mappedColor]?.[level] || ''
  }

  // 根据主题模式获取通用颜色值
  function getSemanticValue(category: keyof ThemeColorSemanticConfig, key: string, grayColor: string): string {
    const currentSemantic = isDark.value ? finalConfig.colorSemantic.dark : finalConfig.colorSemantic.light
    const value = currentSemantic[category][key as keyof typeof currentSemantic[typeof category]]

    if (value === 'white' || value === 'black') {
      return `var(--ui-color-${value})`
    }
    return `var(--base-color-${grayColor}-${value})`
  }

  const color2rgb = (color: string) => {
    const rgb = hex2rgb(color)
    return `${rgb.r} ${rgb.g} ${rgb.b}`
  }

  // 生成CSS变量字符串
  function generateCSSVariables(): string {
    const baseVars: string[] = []
    Object.entries(finalConfig.colors).forEach(([colorName, shades]) => {
      if (typeof shades === 'object') {
        Object.entries(shades).forEach(([shade, value]) => {
          try {
            baseVars.push(`--base-color-${colorName}-${shade}: ${color2rgb(value)};`)
          }
          catch {
            baseVars.push(`--base-color-${colorName}-${shade}: ${value};`)
          }
        })
      }
    })

    // 生成场景变量
    const uiVars: string[] = []
    colorTypes.forEach((type) => {
      const mappedColor = colorMapping.value[type]
      colorShades.forEach((shade) => {
        uiVars.push(`--ui-color-${type}-${shade}: var(--base-color-${mappedColor}-${shade});`)
      })

      colorScenes.forEach((scene) => {
        const sceneLevel = getColorLevel(type, scene)
        if (scene === 'default') {
          uiVars.push(`--ui-color-${type}: var(--base-color-${mappedColor}-${sceneLevel});`)
        }
        else {
          uiVars.push(`--ui-color-${type}-${scene}: var(--base-color-${mappedColor}-${sceneLevel});`)
        }
      })
    })

    // 生成公共变量
    const grayColor = colorMapping.value.gray
    const colorBase: string[] = [
      `--ui-color-white: ${color2rgb(finalConfig.colorBase?.white || '#ffffff')};`,
      `--ui-color-black: ${color2rgb(finalConfig.colorBase?.black || '#000000')};`,

      `--ui-text-dimmed: ${getSemanticValue('text', 'dimmed', grayColor)};`,
      `--ui-text-muted: ${getSemanticValue('text', 'muted', grayColor)};`,
      `--ui-text-toned: ${getSemanticValue('text', 'toned', grayColor)};`,
      `--ui-text: ${getSemanticValue('text', 'base', grayColor)};`,
      `--ui-text-highlighted: ${getSemanticValue('text', 'highlighted', grayColor)};`,
      `--ui-text-inverted: ${getSemanticValue('text', 'inverted', grayColor)};`,

      `--ui-bg: ${getSemanticValue('bg', 'base', grayColor)};`,
      `--ui-bg-muted: ${getSemanticValue('bg', 'muted', grayColor)};`,
      `--ui-bg-elevated: ${getSemanticValue('bg', 'elevated', grayColor)};`,
      `--ui-bg-accented: ${getSemanticValue('bg', 'accented', grayColor)};`,
      `--ui-bg-inverted: ${getSemanticValue('bg', 'inverted', grayColor)};`,

      `--ui-border: ${getSemanticValue('border', 'base', grayColor)};`,
      `--ui-border-muted: ${getSemanticValue('border', 'muted', grayColor)};`,
      `--ui-border-accented: ${getSemanticValue('border', 'accented', grayColor)};`,
      `--ui-border-inverted: ${getSemanticValue('border', 'inverted', grayColor)};`,
    ]

    return `:root {\n  ${baseVars.join('\n  ')}\n  ${uiVars.join('\n  ')}\n  ${colorBase.join('\n  ')}\n}`
  }

  // 手动维护样式节点
  let styleElement: HTMLStyleElement | null = null

  function createOrUpdateStyle() {
    const cssContent = generateCSSVariables()

    if (!styleElement) {
      styleElement = document.createElement('style')
      styleElement.id = 'dvha-variables'
      document.head.appendChild(styleElement)
    }

    styleElement.textContent = cssContent
  }

  // 初始化CSS变量引用
  function cssInit() {
    if (themeStore.cssInit) {
      return
    }
    themeStore.setCssInit()
    createOrUpdateStyle()
  }

  watch([colorMapping, isDark], () => {
    if (!themeStore.cssInit) {
      return
    }
    createOrUpdateStyle()
  }, { deep: true, immediate: false })

  // 设置单个颜色
  function setColor(type: ThemeColorType, colorName: ThemeColorName) {
    if (colors.value.includes(colorName)) {
      themeStore.setThemeColor(type, colorName)
    }
    else {
      console.warn(`Color "${colorName}" is not available`)
    }
  }

  // 设置多个颜色
  function setColors(mappings: Partial<Record<ThemeColorType, ThemeColorName>>) {
    themeStore.setThemeColors(mappings)
  }

  // 重置为默认色彩
  function cssReset() {
    themeStore.resetTheme()
  }

  // 获取阶梯颜色值
  function getShadeColor(type: ThemeColorType, shade: ThemeColorShade, asVariable = false): string {
    if (asVariable) {
      return `--ui-color-${type}-${shade}`
    }
    return getColorValue(type, shade)
  }

  // 获取场景颜色值
  function getSceneColor(type: ThemeColorType, scene?: ThemeSceneType, asVariable = false): string {
    if (!scene) {
      scene = 'default'
    }

    if (asVariable) {
      if (scene === 'default') {
        return `--ui-color-${type})`
      }
      return `--ui-color-${type}-${scene})`
    }

    // 返回具体颜色值
    const level = getColorLevel(type, scene)
    return getColorValue(type, level)
  }

  // 获取公共颜色值
  function getSemanticColor(category: keyof ThemeColorSemanticConfig, key: string, asVariable = false): string {
    if (asVariable) {
      // 构建语义变量名
      let varName: string

      switch (category) {
        case 'text':
          varName = key === 'base' ? '--ui-text' : `--ui-text-${key}`
          break
        case 'bg':
          varName = key === 'base' ? '--ui-bg' : `--ui-bg-${key}`
          break
        case 'border':
          varName = key === 'base' ? '--ui-border' : `--ui-border-${key}`
          break
        default:
          varName = `--ui-${category}-${key}`
      }

      return `${varName}`
    }

    // 返回具体颜色值
    const grayColor = colorMapping.value.gray
    const currentSemantic = isDark.value ? finalConfig.colorSemantic.dark : finalConfig.colorSemantic.light
    const value = currentSemantic[category][key as keyof typeof currentSemantic[typeof category]]

    if (value === 'white') {
      return finalConfig.colorBase?.white || '#ffffff'
    }
    if (value === 'black') {
      return finalConfig.colorBase?.black || '#000000'
    }

    return finalConfig.colors[grayColor]?.[value] || ''
  }

  const neutralColors = computed(() => {
    return colors.value?.filter(color => ['slate', 'gray', 'zinc', 'neutral', 'stone'].includes(color))
  })

  const primaryColors = computed(() => {
    return colors.value?.filter(color => !['slate', 'gray', 'zinc', 'neutral', 'stone'].includes(color))
  })

  return {
    toggle: next,
    mode: state,
    setMode,
    isDark,

    resources,
    config: readonly(finalConfig),
    colorMapping: readonly(colorMapping),

    colors,
    neutralColors,
    primaryColors,

    colorShades,
    colorTypes,
    colorScenes,

    cssInit,
    cssReset,

    setColor,
    setColors,

    getSceneColor,
    getShadeColor,
    getSemanticColor,

  }
}



---
File: /packages/core/src/hooks/tree.ts
---

import { computed, toRef } from 'vue'
import { arrayToTree, treeToArr } from '../utils'
import { useList } from './data'

export interface IUseTreeProps {
  path?: string
  params?: Record<string, any>
  treeOptions?: {
    valueKey?: string
    parentKey?: string
    sortKey?: string
    childrenKey?: string
  }
  converTree?: boolean
  providerName?: string
}

export function useTree(props: IUseTreeProps) {
  const path = toRef(props, 'path')
  const params = toRef(props, 'params')
  const providerName = toRef(props, 'providerName')

  const { data, isLoading } = useList({
    path: path.value || '',
    filters: params.value,
    providerName: providerName.value,
  })

  const options = computed(() => {
    if (!props.converTree) {
      return data.value?.data || []
    }
    return arrayToTree(data.value?.data || [], {
      idKey: props.treeOptions?.valueKey || 'id',
      parentKey: props.treeOptions?.parentKey || 'parent_id',
      sortKey: props.treeOptions?.sortKey || 'sort',
      childrenKey: props.treeOptions?.childrenKey || 'children',
    })
  })

  const expanded = computed(() => {
    return treeToArr(options.value, props.treeOptions?.valueKey || 'id', props.treeOptions?.childrenKey || 'children')
  })

  const loading = computed(() => isLoading.value)

  const optionsData = computed(() => {
    const processOptions = (items: any[]) => {
      return items.map((item) => {
        const newItem = { ...item }
        if (Array.isArray(newItem.children)) {
          if (newItem.children.length === 0) {
            delete newItem.children
          }
          else {
            newItem.children = processOptions(newItem.children)
          }
        }
        return newItem
      })
    }
    return processOptions(options.value || [])
  })

  return {
    options: optionsData,
    loading,
    expanded,
  }
}



---
File: /packages/core/src/hooks/upload.ts
---

import type { UseMutationOptions } from '@tanstack/vue-query'
import type { IDataProviderCustomOptions, IDataProviderError, IDataProviderResponse } from '../types'
import type { IUploadDriver } from './upload/types'
import { useFileDialog } from '@vueuse/core'
import { uniqueId } from 'lodash-es'
import { computed, ref, watch } from 'vue'
import { createLocalUploadDriver } from './upload/local'

export interface IUseUploadProps extends Omit<IDataProviderCustomOptions, 'onUploadProgress' | 'onDownloadProgress'> {
  method?: 'POST' | 'PUT'
  maxFileSize?: number
  maxFileCount?: number
  accept?: string
  multiple?: boolean
  autoUpload?: boolean
  params?: Record<string, string>

  // 驱动实例
  driver?: IUploadDriver

  options?: UseMutationOptions<IDataProviderResponse, IDataProviderError, IDataProviderCustomOptions>
  onSuccess?: (data: IDataProviderResponse) => void
  onError?: (error: IDataProviderError) => void

  onDataCallback?: (data: IDataProviderResponse, file: IUseUploadFile) => Partial<IUseUploadFileData>
  onProgress?: (progress: IOverallProgress) => void
  onCancel?: (id: string) => void
  onComplete?: (data: IUseUploadFile[]) => void

}

export type IUseUploadType = 'file' | 'blob' | 'base64' | 'arrayBuffer'
export type IUseUploadPayload = File | Blob | string | ArrayBuffer

export interface IUseUploadFileData {
  url?: string
  filename?: string
  filesize?: number
  filetype?: string
}

export interface IUseUploadFile extends IUseUploadFileData {
  id: string
  progress?: IUploadProgress
  file?: File
  filesizeText?: string
  status?: 'pending' | 'uploading' | 'success' | 'error' | 'cancelled'
  error?: string
  data?: IDataProviderResponse
}

export interface IUploadProgress {
  loaded: number
  total?: number
  percent?: number
  speed?: number
  speedText?: string
  uploadTime?: number
  remainingTime?: number
}

export interface IOverallProgress {
  index: number
  totalFiles: number
  currentFile?: IUseUploadFile
  totalPercent: number
  totalLoaded: number
  totalSize: number
}

export function useUpload(props?: IUseUploadProps) {
  props = props || {}
  const isUploading = ref<boolean>(false)
  const uploadFiles = ref<IUseUploadFile[]>([])
  const currentUploadingIndex = ref<number>(-1)
  const uploadControllers = ref<Map<string, AbortController>>(new Map())

  // 创建上传驱动 - 默认使用本地驱动
  const uploadDriver = props.driver || createLocalUploadDriver()

  const params = computed(() => {
    const { onProgress, onDataCallback, onCancel, onComplete, maxFileSize, maxFileCount, accept, multiple, autoUpload, options, onSuccess, onError, method, driver, params, ...rest } = props
    return rest
  })

  const method = computed(() => {
    return props.method || 'POST'
  })

  const overallProgress = computed<IOverallProgress>(() => {
    const totalFiles = uploadFiles.value.length
    const totalSize = uploadFiles.value.reduce((sum, file) => sum + (file.filesize || 0), 0)

    let totalLoaded = 0
    let overallPercent = 0

    uploadFiles.value.forEach((file, index) => {
      if (index < currentUploadingIndex.value) {
        totalLoaded += file.filesize || 0
      }
      else if (index === currentUploadingIndex.value) {
        totalLoaded += file.progress?.loaded || 0
      }
    })

    if (totalSize > 0) {
      overallPercent = Math.round((totalLoaded / totalSize) * 100)
    }

    // index 计算：没有上传时为 0，上传时从 1 开始计数
    const index = currentUploadingIndex.value >= 0 ? currentUploadingIndex.value + 1 : 0

    return {
      index,
      totalFiles,
      currentFile: uploadFiles.value[currentUploadingIndex.value],
      totalPercent: overallPercent,
      totalLoaded,
      totalSize,
    }
  })

  const formatFileSize = (bytes: number): string => {
    if (bytes === 0) {
      return '0 Bytes'
    }
    const k = 1024
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    return `${Number.parseFloat((bytes / k ** i).toFixed(2))} ${sizes[i]}`
  }

  // 格式化上传速度
  const formatSpeed = (bytesPerSecond: number): string => {
    if (bytesPerSecond === 0) {
      return '0 B/s'
    }
    const k = 1024
    const sizes = ['B/s', 'KB/s', 'MB/s', 'GB/s']
    const i = Math.floor(Math.log(bytesPerSecond) / Math.log(k))
    return `${Number.parseFloat((bytesPerSecond / k ** i).toFixed(2))} ${sizes[i]}`
  }

  const generateId = (): string => {
    return uniqueId('upload-')
  }

  const convertToFile = async (payload: IUseUploadPayload, type: IUseUploadType, filename?: string): Promise<File> => {
    switch (type) {
      case 'file': {
        if (!(payload instanceof File)) {
          throw new TypeError('Payload must be a File when type is "file"')
        }
        return payload
      }
      case 'blob': {
        if (!(payload instanceof Blob)) {
          throw new TypeError('Payload must be a Blob when type is "blob"')
        }
        return new File([payload], filename || 'blob-file', { type: payload.type })
      }
      case 'base64': {
        if (typeof payload !== 'string') {
          throw new TypeError('Payload must be a string when type is "base64"')
        }
        const base64Data = payload.includes(',') ? payload.split(',')[1] : payload
        const mimeType = payload.includes(',') ? payload.split(',')[0].split(':')[1].split(';')[0] : 'application/octet-stream'
        const byteCharacters = atob(base64Data)
        const byteArray = new Uint8Array(byteCharacters.length)
        for (let i = 0; i < byteCharacters.length; i++) {
          byteArray[i] = byteCharacters.charCodeAt(i)
        }
        const blob = new Blob([byteArray], { type: mimeType })
        return new File([blob], filename || 'base64-file', { type: mimeType })
      }
      case 'arrayBuffer': {
        if (!(payload instanceof ArrayBuffer)) {
          throw new TypeError('Payload must be ArrayBuffer when type is "arrayBuffer"')
        }
        const arrayBlob = new Blob([payload])
        return new File([arrayBlob], filename || 'array-buffer-file', { type: 'application/octet-stream' })
      }
      default: {
        throw new Error(`Unsupported upload type: ${type}`)
      }
    }
  }

  // process file upload
  const checkFile = (file: File) => {
    if (props.maxFileSize && file.size > props.maxFileSize) {
      throw new Error(`File size cannot exceed ${formatFileSize(props.maxFileSize)}`)
    }

    if (props.maxFileCount && uploadFiles.value.length >= props.maxFileCount) {
      throw new Error(`File count cannot exceed ${props.maxFileCount}`)
    }
  }

  // add file to upload list
  const addFile = async (payload: IUseUploadPayload, type: IUseUploadType, filename?: string): Promise<IUseUploadFile> => {
    const file = await convertToFile(payload, type, filename)

    checkFile(file)

    const uploadFile: IUseUploadFile = {
      id: generateId(),
      file,
      filename: file.name,
      filesize: file.size,
      filetype: file.type,
      filesizeText: formatFileSize(file.size),
      status: 'pending',
      progress: {
        loaded: 0,
        total: file.size,
        percent: 0,
        speed: 0,
        speedText: formatSpeed(0),
        remainingTime: 0,
        uploadTime: 0,
      },
    }

    uploadFiles.value.push(uploadFile)
    return uploadFile
  }

  // update file status
  const updateFileStatus = (id: string, updates: Partial<IUseUploadFile>) => {
    const index = uploadFiles.value.findIndex(f => f.id === id)
    if (index !== -1) {
      uploadFiles.value[index] = { ...uploadFiles.value[index], ...updates }
    }
  }

  // trigger complete callback
  const triggerComplete = () => {
    const allCompleted = uploadFiles.value.every(file => file.status !== 'uploading')
    if (!allCompleted) {
      return
    }
    props.onComplete?.(uploadFiles.value)
  }

  // cancel file upload
  const cancelFile = (id: string) => {
    const file = uploadFiles.value.find(f => f.id === id)

    if (!file || (file.status !== 'pending' && file.status !== 'uploading')) {
      return false
    }

    if (file.status === 'uploading') {
      const controller = uploadControllers.value.get(id)
      if (controller) {
        controller.abort()
        uploadControllers.value.delete(id)
      }
    }

    updateFileStatus(id, {
      status: 'cancelled',
    })

    props.onCancel?.(id)
    triggerComplete()

    return true
  }

  // cancel files upload
  const cancelFiles = (ids?: string[]) => {
    if (ids) {
      ids.forEach(id => cancelFile(id))
    }
    else {
      uploadFiles.value.forEach(file => cancelFile(file.id))
    }
  }

  // trigger file upload
  const upload = async (uploadFile: IUseUploadFile): Promise<IUseUploadFile> => {
    if (!uploadFile.file) {
      throw new Error('File not found')
    }

    checkFile(uploadFile.file)

    const abortController = new AbortController()
    uploadControllers.value.set(uploadFile.id, abortController)

    const fileStartTime = Date.now()

    updateFileStatus(uploadFile.id, { status: 'uploading' })

    return uploadDriver.upload(uploadFile.file, {
      ...params.value,
      method: method.value,
      signal: abortController.signal,
      params: props.params,
      onUploadProgress: (progressData) => {
        const currentTime = Date.now()
        const elapsedTimeMs = currentTime - fileStartTime
        const elapsedTimeSeconds = elapsedTimeMs / 1000

        const speed = elapsedTimeSeconds > 0 ? progressData.loaded / elapsedTimeSeconds : 0

        const remainingBytes = (progressData.total || 0) - progressData.loaded
        const remainingTime = speed > 0 ? remainingBytes / speed : 0

        const newProgress = {
          loaded: progressData.loaded,
          total: progressData.total,
          percent: progressData.percent || 0,
          speed: Math.round(speed),
          speedText: formatSpeed(speed),
          uploadTime: Math.round(elapsedTimeSeconds),
          remainingTime: Math.round(remainingTime),
        }

        updateFileStatus(uploadFile.id, {
          status: 'uploading',
          progress: newProgress,
        })

        props.onProgress?.(overallProgress.value)
      },
    }).then((response) => {
      if (uploadFile.status === 'cancelled') {
        throw new Error('Upload cancelled')
      }

      const callbackData = props.onDataCallback?.(response, uploadFile) || response.data

      const finalUploadTime = Math.round((Date.now() - fileStartTime) / 1000)

      const updatedFile = {
        ...uploadFile,
        status: 'success' as const,
        data: response,
        ...callbackData,
        progress: {
          ...uploadFile.progress,
          loaded: uploadFile.filesize || 0,
          percent: 100,
          speed: 0,
          speedText: formatSpeed(0),
          uploadTime: finalUploadTime,
          remainingTime: 0,
        },
      }

      updateFileStatus(uploadFile.id, updatedFile)
      uploadControllers.value.delete(uploadFile.id)
      props.onSuccess?.(response)

      return updatedFile
    }).catch((err) => {
      if (err.message === 'canceled' || uploadFile.status === 'cancelled') {
        throw new Error('Upload cancelled')
      }
      updateFileStatus(uploadFile.id, {
        status: 'error',
        error: err.message,
      })
      uploadControllers.value.delete(uploadFile.id)
      throw err
    }).finally(() => {
      triggerComplete()
    })
  }

  // trigger upload
  const trigger = async (): Promise<IUseUploadFile[]> => {
    const pendingFiles = uploadFiles.value.filter(file => file.status === 'pending')
    if (pendingFiles.length === 0) {
      return []
    }

    isUploading.value = true

    try {
      const uploadedFiles: IUseUploadFile[] = []

      for (let i = 0; i < pendingFiles.length; i++) {
        const fileData = pendingFiles[i]

        const fileIndex = uploadFiles.value.findIndex(f => f.id === fileData.id)
        currentUploadingIndex.value = fileIndex

        const uploadedFile = await upload(fileData)
        uploadedFiles.push(uploadedFile)
      }

      return uploadedFiles
    }
    catch (error: any) {
      props.onError?.({
        status: error?.status || 500,
        message: error?.message || 'upload failed',
      })
      throw error
    }
    finally {
      isUploading.value = false
      currentUploadingIndex.value = -1
    }
  }

  // clear all files from upload list
  const clearFiles = () => {
    uploadFiles.value.forEach((file) => {
      cancelFile(file.id)
    })

    uploadControllers.value.clear()

    uploadFiles.value = []
    currentUploadingIndex.value = -1
  }

  // add files to upload list
  const addFiles = async (files: IUseUploadPayload[], type: IUseUploadType = 'file') => {
    try {
      if (!props.multiple && files.length > 1) {
        throw new Error('Single file mode: only one file can be selected')
      }

      if (!props.multiple && uploadFiles.value.length > 0) {
        clearFiles()
      }

      if (props.maxFileCount && uploadFiles.value.length + files.length > props.maxFileCount) {
        throw new Error(`Adding ${files.length} files would exceed the maximum limit of ${props.maxFileCount}`)
      }

      for (const payload of files) {
        await addFile(payload, type)
      }
    }
    catch (error: any) {
      props.onError?.({
        status: error?.status || 400,
        message: error?.message || 'Failed to add files',
      })
      throw error
    }

    if (props.autoUpload) {
      trigger().catch((error) => {
        console.warn('Auto upload failed:', error)
      })
    }
  }

  // remove file from upload list
  const removeFile = (id: string) => {
    const file = uploadFiles.value.find(f => f.id === id)
    if (file && file.status === 'uploading') {
      updateFileStatus(id, {
        status: 'cancelled',
      })

      const controller = uploadControllers.value.get(id)
      if (!controller) {
        return
      }

      controller.abort()
      uploadControllers.value.delete(id)
    }

    const index = uploadFiles.value.findIndex(f => f.id === id)
    if (index !== -1) {
      uploadFiles.value.splice(index, 1)
    }
  }

  // remove files from upload list
  const removeFiles = (ids?: string[]) => {
    if (ids) {
      ids.forEach(id => removeFile(id))
    }
    else {
      uploadFiles.value.forEach(file => removeFile(file.id))
    }
  }

  // file dialog selector
  const { files: selectedFiles, open: openFileDialog, reset: resetFiles } = useFileDialog({
    accept: props.accept,
    multiple: props.multiple || false,
  })

  const createFileFromData = (fileData: IUseUploadFileData): IUseUploadFile => {
    return {
      id: generateId(),
      ...fileData,
      filesizeText: fileData.filesize ? formatFileSize(fileData.filesize) : undefined,
      status: fileData.url ? 'success' : 'pending',
      progress: {
        loaded: 0,
        total: fileData.filesize || 0,
        percent: fileData.url ? 100 : 0,
        speed: 0,
        speedText: formatSpeed(0),
        remainingTime: 0,
        uploadTime: 0,
      },
    }
  }

  watch(selectedFiles, async (newFiles) => {
    if (newFiles && newFiles.length > 0) {
      const fileArray = Array.from(newFiles)
      resetFiles()
      await addFiles(fileArray, 'file').catch((error) => {
        console.warn('Failed to add selected files:', error)
      })
    }
  })

  const dataFiles = computed((): IUseUploadFileData[] => {
    return uploadFiles.value
      .filter(file => file.status === 'success')
      .map((file) => {
        return {
          url: file.url,
          filename: file.filename,
          filesize: file.filesize,
          filetype: file.filetype,
        }
      })
  })

  // add data files to upload list
  const addDataFiles = (dataFiles: IUseUploadFileData[]) => {
    if (!props.multiple && uploadFiles.value.length > 0) {
      clearFiles()
    }

    const newUploadFiles = dataFiles.map(fileData => createFileFromData(fileData))
    uploadFiles.value.push(...newUploadFiles)
  }

  return {
    isUploading,
    uploadFiles,
    dataFiles,
    progress: overallProgress,

    open: openFileDialog,
    trigger,
    resetFiles,
    clearFiles,
    removeFiles,
    addFiles,
    addDataFiles,
    cancelFiles,
  }
}



---
File: /packages/core/src/preset/authProvider.ts
---

import type { IManageHook } from '../hooks'
import type { IUserState } from '../stores'
import type { IAuthActionResponse, IAuthCheckResponse, IAuthErrorResponse, IAuthLoginResponse, IAuthLogoutResponse, IAuthProvider, IDataProviderError } from '../types'
import axios from 'axios'

export interface ISimpleAuthProviderProps {
  apiPath?: {
    login?: string
    check?: string
    logout?: string
    register?: string
    forgotPassword?: string
    updatePassword?: string
  }
  routePath?: {
    login?: string
    index?: string
  }
  dataProviderName?: string
}

export function simpleAuthProvider(props?: ISimpleAuthProviderProps): IAuthProvider {
  return {
    login: async (params: any, manage: IManageHook): Promise<IAuthLoginResponse> => {
      return await axios.post(manage.getApiUrl(props?.apiPath?.login || '/login', props?.dataProviderName), params).then((res) => {
        return {
          success: true,
          message: res?.data?.message,
          redirectTo: props?.routePath?.index || '/',
          data: res?.data?.data as IUserState,
        }
      }).catch((error) => {
        return {
          success: false,
          message: error?.response?.data?.message || error?.message,
        }
      })
    },
    check: async (_params?: any, manage?: IManageHook, auth?: IUserState): Promise<IAuthCheckResponse> => {
      return await axios.get(manage?.getApiUrl(props?.apiPath?.check || '/check', props?.dataProviderName) || '', {
        headers: {
          Authorization: auth?.token || '',
        },
      }).then((res: any) => {
        return {
          success: true,
          logout: false,
          message: res?.data?.message,
          data: res?.data?.data as IUserState,
        }
      }).catch((error) => {
        return {
          success: false,
          logout: true,
          message: error?.response?.data?.message || error?.message,
        }
      })
    },
    onError: async (error?: IDataProviderError): Promise<IAuthErrorResponse> => {
      if (error?.status === 401) {
        return {
          logout: true,
          redirectTo: props?.routePath?.login || '/login',
          error,
        }
      }

      return {
        logout: false,
        error,
      }
    },
    logout: async (): Promise<IAuthLogoutResponse> => {
      return {
        success: true,
        redirectTo: props?.routePath?.login || '/login',
      }
    },
    register: async (params: any, manage?: IManageHook): Promise<IAuthLoginResponse> => {
      return await axios.post(manage?.getApiUrl(props?.apiPath?.register || '/register', props?.dataProviderName) || '', params).then((res: any) => {
        return {
          success: true,
          message: res?.data?.message,
          redirectTo: props?.routePath?.index || '/',
          data: res?.data?.data as IUserState,
        }
      }).catch((error) => {
        return {
          success: false,
          message: error?.response?.data?.message || error?.message,
        }
      })
    },
    forgotPassword: async (params: any, manage?: IManageHook): Promise<IAuthActionResponse> => {
      return await axios.post(manage?.getApiUrl(props?.apiPath?.forgotPassword || '/forgot-password', props?.dataProviderName) || '', params).then((res: any) => {
        return {
          success: true,
          message: res?.data?.message,
          redirectTo: props?.routePath?.login || '/login',
        }
      }).catch((error) => {
        return {
          success: false,
          message: error?.response?.data?.message || error?.message,
        }
      })
    },
    updatePassword: async (params: any, manage?: IManageHook): Promise<IAuthActionResponse> => {
      return await axios.post(manage?.getApiUrl(props?.apiPath?.updatePassword || '/update-password', props?.dataProviderName) || '', params).then((res: any) => {
        return {
          success: true,
          message: res?.data?.message,
          redirectTo: props?.routePath?.login || '/login',
        }
      }).catch((error) => {
        return {
          success: false,
          message: error?.response?.data?.message || error?.message,
        }
      })
    },
    can: (name: string, _params?: any, _manage?: IManageHook, auth?: IUserState): boolean => {
      if (!auth?.permission || (Array.isArray(auth?.permission) && auth?.permission?.length === 0) || (typeof auth?.permission === 'object' && Object.keys(auth?.permission).length === 0)) {
        return true
      }

      if (Array.isArray(auth?.permission) && !auth?.permission?.includes(name)) {
        return false
      }

      if (typeof auth?.permission === 'object' && auth?.permission[name] === false) {
        return false
      }

      return true
    },
  }
}



---
File: /packages/core/src/preset/dataProvider.ts
---

import type { IManageHook } from '../hooks'
import type { IUserState } from '../stores'
import type { IDataProvider, IDataProviderCreateManyOptions, IDataProviderCreateOptions, IDataProviderCustomOptions, IDataProviderDeleteManyOptions, IDataProviderDeleteOptions, IDataProviderError, IDataProviderGetManyOptions, IDataProviderGetOneOptions, IDataProviderListOptions, IDataProviderResponse, IDataProviderUpdateManyOptions, IDataProviderUpdateOptions } from '../types'
import axios from 'axios'
import { trim } from 'lodash-es'

export interface ISimpleDataProviderProps {
  apiUrl: string
  successCallback?: (res: any) => IDataProviderResponse
  errorCallback?: (err: any) => IDataProviderError
  getTotal?: (options: IDataProviderResponse) => number
}

// 检查对象是否包含File类型
function hasFileInObject(obj: any): boolean {
  return Object.values(obj).some((value) => {
    if (value instanceof File)
      return true
    if (Array.isArray(value))
      return value.some(item => item instanceof File)
    if (value && typeof value === 'object')
      return hasFileInObject(value)
    return false
  })
}

// 将包含File的对象转换为FormData
function convertToFormData(data: any): FormData {
  const formData = new FormData()

  const append = (obj: any, prefix = '') => {
    Object.entries(obj).forEach(([key, value]) => {
      const fieldName = prefix ? `${prefix}[${key}]` : key

      if (value instanceof File) {
        formData.append(fieldName, value)
      }
      else if (Array.isArray(value)) {
        value.forEach((item, index) => {
          if (item instanceof File) {
            formData.append(`${fieldName}[${index}]`, item)
          }
          else if (item != null) {
            formData.append(`${fieldName}[${index}]`, String(item))
          }
        })
      }
      else if (value && typeof value === 'object') {
        append(value, fieldName)
      }
      else if (value != null) {
        formData.append(fieldName, String(value))
      }
    })
  }

  append(data)
  return formData
}

export function simpleDataProvider(props: ISimpleDataProviderProps): IDataProvider {
  const apiUrl = (path?: string, basePath?: string): string => {
    const prefixUrl = `${trim(props.apiUrl, '/')}${basePath ? `/${trim(basePath, '/')}` : ''}`
    return path ? `${prefixUrl}/${trim(path || '', '/')}` : prefixUrl
  }

  return {
    apiUrl,
    getList: (options: IDataProviderListOptions, manage?: IManageHook, auth?: IUserState) => {
      const params: Record<string, any> = {}

      if (options.pagination && typeof options.pagination === 'object') {
        params.page = options.pagination.page
        params.pageSize = options.pagination.pageSize
      }

      return axios.get(apiUrl(options.path, manage?.config.apiBasePath) || '', {
        params: {
          ...params,
          ...options.filters,
          ...options.sorters,
        },
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    create: (options: IDataProviderCreateOptions, manage?: IManageHook, auth?: IUserState) => {
      // 检查并转换包含File的数据
      let requestData = options.data
      if (options.data && typeof options.data === 'object' && !Array.isArray(options.data) && !(options.data instanceof FormData)) {
        if (hasFileInObject(options.data)) {
          requestData = convertToFormData(options.data)
        }
      }

      return axios.post(apiUrl(options.path, manage?.config.apiBasePath) || '', requestData, {
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    update: (options: IDataProviderUpdateOptions, manage?: IManageHook, auth?: IUserState) => {
      let requestData = options.data
      if (options.data && typeof options.data === 'object' && !Array.isArray(options.data) && !(options.data instanceof FormData)) {
        if (hasFileInObject(options.data)) {
          requestData = convertToFormData(options.data)
        }
      }

      return axios.put(apiUrl(options.id ? `${options.path}/${options.id}` : options.path, manage?.config.apiBasePath) || '', requestData, {
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    deleteOne: (options: IDataProviderDeleteOptions, manage?: IManageHook, auth?: IUserState) => {
      return axios.delete(apiUrl(options.id ? `${options.path}/${options.id}` : options.path, manage?.config.apiBasePath) || '', {
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    getOne: (options: IDataProviderGetOneOptions, manage?: IManageHook, auth?: IUserState) => {
      return axios.get(apiUrl(options.id ? `${options.path}/${options.id}` : options.path, manage?.config.apiBasePath) || '', {
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    getMany: (options: IDataProviderGetManyOptions, manage?: IManageHook, auth?: IUserState) => {
      return axios.get(apiUrl(options.path, manage?.config.apiBasePath) || '', {
        params: {
          ids: options.ids,
        },
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    createMany: (options: IDataProviderCreateManyOptions, manage?: IManageHook, auth?: IUserState) => {
      return axios.post(apiUrl(options.path, manage?.config.apiBasePath) || '', options.data, {
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    updateMany: (options: IDataProviderUpdateManyOptions, manage?: IManageHook, auth?: IUserState) => {
      return axios.put(apiUrl(options.path, manage?.config.apiBasePath) || '', {
        ids: options.ids,
        data: options.data,
      }, {
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    deleteMany: (options: IDataProviderDeleteManyOptions, manage?: IManageHook, auth?: IUserState) => {
      return axios.delete(apiUrl(options.path, manage?.config.apiBasePath) || '', {
        params: {
          ids: options.ids,
        },
        headers: {
          Authorization: auth?.token,
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    custom: (options: IDataProviderCustomOptions, manage?: IManageHook, auth?: IUserState) => {
      let params: Record<string, any> = {
        ...options.query,
      }

      if (options.sorters && typeof options.sorters === 'object') {
        params = {
          ...params,
          ...options.sorters,
        }
      }

      if (options.filters && typeof options.filters === 'object') {
        params = {
          ...params,
          ...options.filters,
        }
      }

      return axios.request({
        url: apiUrl(options.path, manage?.config.apiBasePath) || '',
        method: options.method || 'GET',
        data: options.payload,
        params,
        signal: options.signal,
        headers: {
          Authorization: auth?.token,
          ...options.headers,
        },
        onUploadProgress: (progressEvent) => {
          const percent = Math.round((progressEvent.loaded * 100) / (progressEvent.total || 1))
          options.onUploadProgress?.({
            loaded: progressEvent.loaded,
            total: progressEvent.total,
            percent,
          })
        },
        onDownloadProgress: (progressEvent) => {
          const percent = Math.round((progressEvent.loaded * 100) / (progressEvent.total || 1))
          options.onDownloadProgress?.({
            loaded: progressEvent.loaded,
            total: progressEvent.total,
            percent,
          })
        },
        ...options.meta,
      }).then((res) => {
        return props.successCallback ? props.successCallback(res) : handleResponse(res)
      }).catch((err) => {
        throw props.errorCallback ? props.errorCallback(err) : handleError(err)
      })
    },
    getTotal: (options: IDataProviderResponse) => {
      return props.getTotal ? props.getTotal(options) : options.meta?.total || 0
    },
  }
}

function handleResponse(res: any): IDataProviderResponse {
  return {
    message: res.data?.message,
    data: res.data?.data,
    meta: res.data?.meta,
    raw: res.data,
  }
}

function handleError(err: any): IDataProviderError {
  return {
    message: err.response?.data?.message || err?.message,
    data: err.response?.data?.data,
    meta: err.response?.data?.meta,
    status: err.response?.data?.code || err.response?.status || 500,
    raw: err.response?.data,
  }
}



---
File: /packages/core/src/preset/i18nProvider.ts
---

import type { I18nOptions } from 'vue-i18n'
import type { I18nProvider } from '../types'
import { createI18n } from 'vue-i18n'

export function i18nProvider(props?: I18nOptions): I18nProvider {
  const i18n = createI18n({
    legacy: false,
    locale: props?.locale,
    fallbackLocale: props?.fallbackLocale,
    messages: props?.messages,
    missingWarn: false,
    fallbackWarn: false,
  })

  return {
    t: (key: string, options?: any, defaultMessage?: string): string => {
      const result = i18n.global.t(key, options)
      if (result === key && defaultMessage) {
        return defaultMessage
      }
      return result
    },
    changeLocale: (lang: string, _options?: any): Promise<any> => {
      return new Promise((resolve) => {
        i18n.global.locale.value = lang
        resolve(lang)
      })
    },
    loadLocale: (lang: string, file: Record<string, unknown>) => {
      return new Promise((resolve) => {
        i18n.global.setLocaleMessage(lang, file)
        resolve(lang)
      })
    },
    mergeLocale: (lang: string, messages: Record<string, unknown>) => {
      i18n.global.mergeLocaleMessage(lang, messages)
    },
    getLocale: () => {
      return i18n.global.locale.value
    },
    getLocales: () => {
      return i18n.global.availableLocales.map(locale => locale)
    },
  }
}



---
File: /packages/core/src/preset/index.ts
---

export * from './authProvider'
export * from './dataProvider'
export * from './i18nProvider'



---
File: /packages/core/src/provider/app.tsx
---

import type { Ref } from 'vue'
import type { RouteRecordRaw } from 'vue-router'
import type { IDataProvider, IManage, IMenu } from '../types'
import { OverlaysProvider } from '@overlastic/vue'
import { defineComponent, inject } from 'vue'
import { useRouter } from 'vue-router'
import { DuxError, DuxNotAuthorized, DuxNotFound } from '../components'
import { initJsonSchemaComponents, useCan, useConfig, useManage } from '../hooks'
import { useAuthStore, useI18nStore, useRouteStore } from '../stores'
import { useManageStore } from '../stores/manage'

export const DuxAppProvider = defineComponent({
  name: 'DuxAppProvider',
  props: {
  },
  setup(_props, { slots }) {
    const manageRef = inject<Ref<string>>('dux.manage')

    const config = useConfig()
    const router = useRouter()

    router.beforeEach(async (to, _from, next) => {
      const manageName = to.meta.manageName as string
      const noAuth = to.meta.authorization === false

      if (!manageName) {
        const defaultManage = config.defaultManage || config.manages?.[0]?.name || ''
        return next({
          path: `/${defaultManage}`,
          replace: true,
        })
      }

      if (manageRef) {
        manageRef.value = manageName
      }

      const manageStore = useManageStore(manageName)
      if (!manageStore.isInit()) {
        manageStore.setConfig(config.manages?.find(manage => manage.name === manageName) as IManage, config)
      }

      const routeStore = useRouteStore(manageName)
      const manage = useManage(manageName)
      const authStore = useAuthStore(manageName)
      const i18nStore = useI18nStore(manageName)

      // init i18n
      if (manage.config?.i18nProvider && !i18nStore.isInit()) {
        const locale = i18nStore.getLocale()
        if (locale) {
          manage.config?.i18nProvider.changeLocale(locale)
        }
      }

      // init json schema components
      initJsonSchemaComponents(config, manageName)

      // unlogin handle
      if (!authStore.isLogin()) {
        if (noAuth) {
          return next()
        }

        return next({
          path: manage.getRoutePath(`login`),
          replace: true,
        })
      }

      const formatMenus = (menus: IMenu[]) => {
        return menus?.map((item: IMenu) => {
          return {
            ...item,
            path: item.path ? manage.getRoutePath(item.path) : undefined,
          }
        })
      }

      // loading route
      if (!routeStore.getRouteInit()) {
        // components
        const components = manage.config?.components || {}
        const commonRoutes: IMenu[] = []

        commonRoutes.push({
          name: `${manageName}.notFound`,
          label: '404',
          path: ':pathMatch(.*)*',
          component: components.notFound || DuxNotFound,
          hidden: true,
          meta: {
            can: false,
          },
        })

        commonRoutes.push({
          name: `${manageName}.notAuthorized`,
          label: '403',
          path: 'notAuthorized',
          component: components.notAuthorized || DuxNotAuthorized,
          hidden: true,
          meta: {
            can: false,
          },
        })

        commonRoutes.push({
          name: `${manageName}.error`,
          label: '500',
          path: 'error',
          component: components.error || DuxError,
          hidden: true,
          meta: {
            can: false,
          },
        })

        // loading local route
        routeStore.setRoutes(formatMenus(manage.config?.menus || []))

        // loading remote route
        if (manage.config?.apiRoutePath) {
          await (manage.config?.dataProvider as Record<string, IDataProvider>)?.default?.custom({
            path: manage.config.apiRoutePath,
            meta: {
              timeout: 5000,
            },
          }, manage, authStore.getUser()).then((res) => {
            routeStore.appendRoutes(formatMenus(res.data || []))
          }).catch((error) => {
            manage.config?.authProvider?.onError?.(error).then((err) => {
              if (err?.logout) {
                authStore.logout()
                router.push(manage.getRoutePath(err.redirectTo || '/login'))
              }
            })
            throw error
          })
        }

        // init common routes
        routeStore.appendRoutes(commonRoutes)

        // register route
        routeStore.getRoutes().forEach((item: IMenu) => {
          if (!item.path) {
            return
          }

          const route: Partial<RouteRecordRaw> = {
            name: item.name,
            path: item.path,
            meta: item.meta,
          }

          switch (item.loader) {
            case 'iframe':
              route.component = manage.config?.components?.iframe || (() => import('../components/loader/iframe'))
              break
            case 'remote':
              route.component = manage.config?.components?.remote || (() => import('../components/loader/loader'))
              break
            case 'link':
              route.beforeEnter = () => {
                const url = item.meta?.url || item.path
                if (url) {
                  window.open(url, '_blank')
                }
                return false
              }
              route.component = () => Promise.resolve({ template: '<div></div>' })
              break
            default:
              if (item.component) {
                route.component = item.component
              }
              break
          }

          router.addRoute(`${manageName}.auth`, route as RouteRecordRaw)
        })

        // reload route
        return next({
          path: to.redirectedFrom?.path || to.path,
          replace: true,
        })
      }

      const pathMatch = [
        '',
        '/',
        `/${manageName}`,
        `/${manageName}/`,
      ]

      // index route redirect
      if (pathMatch.includes(to.path)) {
        const indexRoute = routeStore.getIndexRoute()

        // if index route is not found
        if (!indexRoute?.path || pathMatch.includes(indexRoute?.path)) {
          console.warn(`[Dux] index route not found, skip redirect`)
          return next()
        }

        return next({
          path: indexRoute?.path || '/',
          replace: true,
        })
      }

      const can = useCan(manageName)

      if ((to.meta?.can === undefined || to.meta?.can === true) && !can(to.name as string)) {
        return next({
          name: `${manageName}.notAuthorized`,
        })
      }

      return next()
    })

    return () => (
      <OverlaysProvider>
        {slots.default?.()}
      </OverlaysProvider>
    )
  },
})



---
File: /packages/core/src/provider/index.ts
---

export * from './app'
export * from './tab'



---
File: /packages/core/src/provider/tab.tsx
---

import { defineComponent, KeepAlive, Transition, watch } from 'vue'
import { RouterView, useRoute } from 'vue-router'
import { useRouteStore, useTabStore } from '../stores'

export const DuxTabRouterView = defineComponent({
  name: 'DuxTabRouterView',
  props: {},
  setup() {
    const route = useRoute()
    const tabStore = useTabStore()
    const routeStore = useRouteStore()

    // route cache
    const cacheMap = new Map()

    const wrap = (name: string, component: any) => {
      let cache
      const cacheName = name

      if (cacheMap.has(cacheName)) {
        cache = cacheMap.get(cacheName)
      }
      else {
        cache = {
          name: cacheName,
          render() {
            return component
          },
        }
        cacheMap.set(cacheName, cache)
      }
      return cache
    }

    tabStore.$subscribe((_mutation, state) => {
      cacheMap.forEach((cache) => {
        if (!state.tabs.some(t => t.path === cache.name)) {
          cacheMap.delete(cache.name)
        }
      })
    })

    // add index route
    const indexRoute = routeStore.getIndexRoute()
    if (indexRoute) {
      tabStore.addTab({ ...indexRoute, meta: { ...indexRoute.meta, lock: true } })
    }

    // watch route and routeStore.routes
    watch([route, () => routeStore.routes], () => {
      const info = routeStore.searchRouteName(route.name as string)
      if (!info) {
        return
      }
      const item = { label: info.label as string, path: route.path, name: info.name }
      tabStore.addTab(item)
    }, { immediate: true })

    return () => (
      <RouterView>
        {{
          default: ({ Component }) => {
            const WrappedComponent = wrap(route.path, Component)
            return (
              <Transition name="tab-fade" mode="out-in" appear>
                <KeepAlive include={tabStore.tabs.map(t => t.path || '')}>
                  <WrappedComponent key={route.path} />
                </KeepAlive>
              </Transition>
            )
          },
        }}
      </RouterView>
    )
  },
})



---
File: /packages/core/src/router/index.ts
---

export * from './route'



---
File: /packages/core/src/router/route.ts
---

import type { RouteRecordRaw } from 'vue-router'
import type { IConfig } from '../types'
import { createRouter, createWebHashHistory } from 'vue-router'

export function initRouter(config: IConfig) {
  const routes: RouteRecordRaw[] = [
    ...config.routes || [],
    {
      name: 'default',
      path: '/:catchAll(.*)',
      redirect: `/${config.defaultManage || config.manages?.[0]?.name || ''}`,
    },
  ]

  config.manages?.forEach((manage) => {
    const authRoutes = manage.routes?.filter(route => route.meta?.authorization === true || route.meta?.authorization === undefined) || []
    const noAuthRoutes = manage.routes?.filter(route => route.meta?.authorization === false) || []

    routes.push({
      name: manage.name,
      path: manage.routePrefix || '',
      children: [
        {
          path: '',
          name: `${manage.name}.auth`,
          component: manage.components?.authLayout,
          children: authRoutes,
        },
        {
          path: '',
          name: `${manage.name}.noAuth`,
          component: manage.components?.noAuthLayout,
          children: noAuthRoutes,
        },
      ],
      meta: {
        manageName: manage.name,
      },
    })
  })

  return createRouter({
    history: createWebHashHistory(),
    routes,
  })
}



---
File: /packages/core/src/stores/auth.ts
---

import type { Ref } from 'vue'
import { defineStore } from 'pinia'
import { inject, ref } from 'vue'

export interface IUserState {
  token?: string
  id?: number
  info?: Record<string, any>
  permission?: any
}

export interface AuthStoreState {
  data: Ref<IUserState | undefined>
  getUser: () => IUserState
  login: (params: IUserState) => void
  isLogin: () => boolean
  logout: () => void
  update: (params: IUserState) => void
  updateKey: (key: string, value: any) => void
}

/**
 * use auth store
 * @param manageName manage name
 * @returns auth store
 */
export function useAuthStore(manageName?: string) {
  const manage = inject<Ref<string>>('dux.manage')
  if (!manageName) {
    manageName = manage?.value || ''
  }

  if (!manageName) {
    throw new Error('manage not found')
  }

  const authStore = createAuthStore(manageName)
  return authStore()
}

/**
 * create auth store
 * @param manageName manage name
 * @returns auth store
 */
function createAuthStore(manageName: string) {
  return defineStore<string, AuthStoreState>(`auths-${manageName}`, () => {
    const data = ref<IUserState>()

    const isLogin = (): boolean => {
      return !!data.value?.token
    }

    const getUser = (): IUserState => {
      return data.value || {}
    }

    const login = (params: IUserState) => {
      data.value = {
        token: params?.token,
        id: params?.id,
        info: params?.info,
        permission: params?.permission,
      }
    }

    const update = (params: IUserState) => {
      data.value = {
        token: params?.token,
        id: params?.id,
        info: params?.info,
        permission: params?.permission,
      }
    }

    const updateKey = (key: string, value: any) => {
      data.value = {
        ...data.value,
        [key]: value,
      }
    }

    const logout = () => {
      data.value = undefined
    }

    return {
      data,
      getUser,
      login,
      isLogin,
      logout,
      update,
      updateKey,
    }
  }, {
    persist: true,
  })
}



---
File: /packages/core/src/stores/i18n.ts
---

import type { Ref } from 'vue'
import { defineStore } from 'pinia'
import { inject, ref } from 'vue'

export interface I18nStoreState {
  lang: Ref<string>
  isInit: () => boolean
  setLocale: (value: string) => void
  getLocale: () => string
}

/**
 * use i18n store
 * @param manageName manage name
 * @returns i18n store
 */
export function useI18nStore(manageName?: string) {
  const manage = inject<Ref<string>>('dux.manage')
  if (!manageName) {
    manageName = manage?.value || ''
  }

  if (!manageName) {
    throw new Error('manage not found')
  }

  const i18nStore = createI18nStore(manageName)
  return i18nStore()
}

/**
 * create manage store
 * @param manageName manage name
 * @returns manage store
 */
function createI18nStore(manageName: string) {
  return defineStore<string, I18nStoreState>(`i18n-${manageName}`, () => {
    const lang = ref<string>('')

    const init = ref<boolean>(false)

    const isInit = () => {
      const value = init.value
      init.value = true
      return value
    }

    const setLocale = (value: string) => {
      lang.value = value
    }

    const getLocale = () => {
      return lang.value
    }

    return {
      lang,
      isInit,
      setLocale,
      getLocale,
    }
  }, {
    persist: {
      pick: ['lang'],
    },
  })
}



---
File: /packages/core/src/stores/index.ts
---

export * from './auth'
export * from './i18n'
export * from './jsonSchema'
export * from './manage'
export * from './route'
export * from './tab'
export * from './theme'



---
File: /packages/core/src/stores/jsonSchema.ts
---

import type { Component, Ref } from 'vue'
import { defineStore } from 'pinia'
import { inject, ref } from 'vue'

/**
 * 组件缓存项
 */
interface ComponentCacheItem {
  component: Component
  name: string
  originalName: string
  cacheKey: string
}

export interface JsonSchemaStoreState {
  componentCache: Ref<Map<string, ComponentCacheItem>>
  componentsByName: Ref<Map<string, Component>>
  addComponent: (component: Component, name: string, originalName?: string) => string
  getComponent: (key: string) => Component | undefined
  getComponentByName: (name: string) => Component | undefined
  hasComponent: (key: string) => boolean
  clearCache: () => void
  getCacheSize: () => number
}

/**
 * 生成组件缓存键
 */
function generateCacheKey(name: string): string {
  // 组件名本身就是唯一的，直接使用
  return name
}

/**
 * use json schema store
 * @param manageName manage name
 * @returns json schema store
 */
export function useJsonSchemaStore(manageName?: string) {
  const manage = inject<Ref<string>>('dux.manage')
  if (!manageName) {
    manageName = manage?.value || ''
  }

  if (!manageName) {
    throw new Error('manage not found')
  }

  const jsonSchemaStore = createJsonSchemaStore(manageName)
  return jsonSchemaStore()
}

/**
 * create json schema store
 * @param manageName manage name
 * @returns json schema store
 */
function createJsonSchemaStore(manageName: string) {
  return defineStore<string, JsonSchemaStoreState>(`jsonSchema-${manageName}`, () => {
    const componentCache = ref<Map<string, ComponentCacheItem>>(new Map())
    const componentsByName = ref<Map<string, Component>>(new Map())

    /**
     * 添加组件到缓存
     */
    const addComponent = (component: Component, name: string, originalName?: string): string => {
      const cacheKey = generateCacheKey(name)

      if (!componentCache.value.has(cacheKey)) {
        componentCache.value.set(cacheKey, {
          component,
          name,
          originalName: originalName || name,
          cacheKey,
        })

        // 同时添加到按名称索引的映射中
        componentsByName.value.set(name, component)
      }

      return cacheKey
    }

    /**
     * 从缓存获取组件
     */
    const getComponent = (key: string): Component | undefined => {
      return componentCache.value.get(key)?.component
    }

    /**
     * 根据名称获取组件
     */
    const getComponentByName = (name: string): Component | undefined => {
      return componentsByName.value.get(name)
    }

    /**
     * 检查缓存中是否存在组件
     */
    const hasComponent = (key: string): boolean => {
      return componentCache.value.has(key)
    }

    /**
     * 清空缓存
     */
    const clearCache = () => {
      componentCache.value.clear()
      componentsByName.value.clear()
    }

    /**
     * 获取缓存大小
     */
    const getCacheSize = () => {
      return componentCache.value.size
    }

    return {
      componentCache,
      componentsByName,
      addComponent,
      getComponent,
      getComponentByName,
      hasComponent,
      clearCache,
      getCacheSize,
    }
  })
}



---
File: /packages/core/src/stores/manage.ts
---

import type { Ref } from 'vue'
import type { IConfig, IDataProvider, IManage } from '../types'
import { cloneDeep } from 'lodash-es'
import { defineStore } from 'pinia'
import { inject, markRaw, ref } from 'vue'

export interface ManageStoreState {
  config: Ref<IManage | undefined>
  isInit: () => boolean
  setConfig: (manageConfig: IManage, globalConfig: IConfig) => void
  getConfig: () => IManage | undefined
}

/**
 * 判断是否为 Record<string, IDataProvider> 类型
 * @param value 要判断的值
 * @returns 是否为记录类型
 */
function isDataProviderRecord(value: IDataProvider | Record<string, IDataProvider> | undefined): value is Record<string, IDataProvider> {
  return value !== null
    && value !== undefined
    && typeof value === 'object'
    && !Array.isArray(value)
    && typeof (value as any).getList !== 'function'
}

/**
 * use manage store
 * @param manageName manage name
 * @returns manage store
 */
export function useManageStore(manageName?: string) {
  const manage = inject<Ref<string>>('dux.manage')
  if (!manageName) {
    manageName = manage?.value || ''
  }

  if (!manageName) {
    throw new Error('manage not found')
  }

  const manageStore = createManageStore(manageName)
  return manageStore()
}

/**
 * create manage store
 * @param manageName manage name
 * @returns manage store
 */
function createManageStore(manageName: string) {
  return defineStore<string, ManageStoreState>(`manages-${manageName}`, () => {
    const config = ref<IManage>()
    const isInitConfig = ref<boolean>(false)

    const isInit = () => {
      const init = isInitConfig.value
      isInitConfig.value = true
      return init
    }

    const setConfig = (manageConfig: IManage, globalConfig: IConfig) => {
      const manage = cloneDeep(manageConfig)

      const title: string[] = []
      if (manage.title) {
        title.push(manage.title)
      }
      if (globalConfig.title) {
        title.push(globalConfig.title)
      }
      manage.title = title.join(' - ')

      manage.copyright = manage.copyright || globalConfig.copyright
      manage.description = manage.description || globalConfig.description

      manage.theme = { ...globalConfig?.theme, ...manage?.theme }

      const dataProvider: Record<string, IDataProvider> = {}

      if (globalConfig?.dataProvider) {
        if (isDataProviderRecord(globalConfig.dataProvider)) {
          Object.keys(globalConfig.dataProvider).forEach((key) => {
            dataProvider[key] = globalConfig.dataProvider![key]
          })
        }
        else {
          dataProvider.default = globalConfig.dataProvider
        }
      }

      if (manage?.dataProvider) {
        if (isDataProviderRecord(manage.dataProvider)) {
          Object.keys(manage.dataProvider).forEach((key) => {
            dataProvider[key] = manage.dataProvider![key]
          })
        }
        else {
          dataProvider.default = manage.dataProvider
        }
      }

      manage.authProvider = globalConfig?.authProvider || manage?.authProvider
      manage.dataProvider = dataProvider
      manage.i18nProvider = globalConfig?.i18nProvider || manage?.i18nProvider

      manage.layoutComponent = {
        ...globalConfig.layoutComponent,
        ...manage.layoutComponent,
      }

      const components = {
        ...globalConfig.components,
        ...manage.components,
      }

      if (components) {
        Object.keys(components).forEach((key) => {
          if (components[key]) {
            components[key] = markRaw(components[key])
          }
        })
      }

      manage.components = components

      manage.remote = {
        ...globalConfig.remote,
        ...manage.remote,
      }

      config.value = manage
    }

    const getConfig = () => {
      return config.value
    }

    return {
      config,
      isInit,
      setConfig,
      getConfig,
    }
  })
}



---
File: /packages/core/src/stores/route.ts
---

import type { Ref } from 'vue'
import type { IMenu } from '../types'
import { defineStore } from 'pinia'
import { inject, ref } from 'vue'

export interface RouteStoreState {
  routes: Ref<IMenu[]>
  searchRoute: (path: string) => IMenu | undefined
  searchRouteName: (name: string) => IMenu | undefined
  appendRoute: (data: IMenu) => void
  appendRoutes: (data: IMenu[]) => void
  setRoutes: (data: IMenu[]) => void
  getRoutes: () => IMenu[]
  clearRoutes: () => void
  getIndexRoute: () => IMenu | undefined
  getRouteInit: () => boolean
}

/**
 * use route store
 * @param manageName manage name
 * @returns route store
 */
export function useRouteStore(manageName?: string) {
  const manage = inject<Ref<string>>('dux.manage')
  if (!manageName) {
    manageName = manage?.value || ''
  }

  if (!manageName) {
    throw new Error('manage not found')
  }

  const routeStore = createRouteStore(manageName)
  return routeStore()
}

/**
 * create route store
 * @param manageName manage name
 * @returns route store
 */
function createRouteStore(manageName: string) {
  return defineStore<string, RouteStoreState>(`routes-${manageName}`, () => {
    const routes = ref<IMenu[]>([])

    /**
     * search route by path
     * @param path route path
     * @returns route object
     */
    const searchRoute = (path: string) => {
      return routes.value?.find((item) => {
        return item.path === path
      })
    }

    /**
     * search route by name
     * @param name route name
     * @returns route object
     */
    const searchRouteName = (name: string) => {
      return routes.value?.find((item) => {
        return item.name === name
      })
    }

    /**
     * append route
     * @param data route object
     */
    const appendRoute = (data: IMenu) => {
      routes.value?.push(data)
    }

    /**
     * append routes
     * @param data route objects
     */
    const appendRoutes = (data: IMenu[]) => {
      routes.value = [...routes.value, ...data]
    }

    /**
     * set routes
     * @param data route objects
     */
    const setRoutes = (data: IMenu[]) => {
      routes.value = data
    }

    /**
     * get routes
     * @returns route objects
     */
    const getRoutes = () => {
      return routes.value
    }

    /**
     * clear routes
     */
    const clearRoutes = () => {
      routes.value = []
    }

    /**
     * get index route
     * @returns route object
     */
    const getIndexRoute = () => {
      const topRoutes = routes.value
        ?.filter(item => !item.parent && !item.name?.includes('404') && !item.name?.includes('403'))
        ?.sort((a, b) => (a.sort || 0) - (b.sort || 0))

      const findFirstValidRoute = (route: IMenu): IMenu | undefined => {
        if (route.path) {
          return route
        }

        const children = routes.value
          ?.filter(item => item.parent === route.name)
          ?.sort((a, b) => (a.sort || 0) - (b.sort || 0))

        for (const child of children || []) {
          const validRoute = findFirstValidRoute(child)
          if (validRoute) {
            return validRoute
          }
        }

        return undefined
      }

      for (const route of topRoutes || []) {
        const validRoute = findFirstValidRoute(route)
        if (validRoute) {
          return validRoute
        }
      }

      return undefined
    }

    const routeInit = ref<boolean>(false)

    const getRouteInit = () => {
      const init = routeInit.value
      routeInit.value = true
      return init
    }

    return {
      routes,
      searchRoute,
      searchRouteName,
      appendRoute,
      appendRoutes,
      setRoutes,
      getRoutes,
      clearRoutes,
      getIndexRoute,
      getRouteInit,
    }
  })
}



---
File: /packages/core/src/stores/tab.ts
---

import type { Ref } from 'vue'
import type { IMenu } from '../types'
import { defineStore } from 'pinia'
import { inject, nextTick, ref } from 'vue'

export interface TabStoreState {
  current: Ref<string | undefined>
  tabs: Ref<IMenu[]>
  isTab: (path: string) => boolean
  addTab: (item: IMenu, cb?: (item: IMenu) => void) => void
  delTab: (path: string, cb?: (item: IMenu) => void) => void
  changeTab: (path: string, cb?: (item: IMenu) => void) => void
  delOther: (path: string, cb?: () => void) => void
  delLeft: (path: string, cb?: () => void) => void
  delRight: (path: string, cb?: () => void) => void
  lockTab: (path: string) => void
  clearTab: () => void
}

export function useTabStore(manageName?: string) {
  const manage = inject<Ref<string>>('dux.manage')
  if (!manageName) {
    manageName = manage?.value || ''
  }

  if (!manageName) {
    throw new Error('manage not found')
  }

  const tabStore = createTabStore(manageName)
  return tabStore()
}

export function createTabStore(manageName: string) {
  return defineStore<string, TabStoreState>(`tab-${manageName}`, () => {
    const current = ref<string>()
    const previousTab = ref<IMenu>()
    const tabs = ref<IMenu[]>([])

    const isTab = (path: string) => {
      return tabs.value.some(tag => tag.path === path)
    }

    const addTab = (item: IMenu, cb?: (item: IMenu) => void) => {
      if (!item.path) {
        return
      }
      if (!tabs.value.some(tag => tag.path === item.path)) {
        if (current.value) {
          previousTab.value = tabs.value.find(t => t.path === current.value)
        }
        tabs.value.push(item)
        cb?.(item)
        current.value = item.path as string
      }
      else {
        if (current.value && current.value !== item.path) {
          previousTab.value = tabs.value.find(t => t.path === current.value)
        }
        current.value = item.path as string
      }
    }

    const delTab = (path: string, cb?: (item: IMenu) => void) => {
      const index = tabs.value.findIndex(t => t.path === path)
      if (index === -1 || tabs.value.length <= 1) {
        return
      }

      const tab = tabs.value[index]
      if (tab?.meta?.lock) {
        return
      }

      let targetTab: IMenu | undefined
      if (path === current.value && previousTab.value) {
        targetTab = tabs.value.find(t => t.path === previousTab.value?.path && t.path !== path)
      }

      if (!targetTab) {
        const prev = tabs.value[index - 1]
        const next = tabs.value[index + 1]
        targetTab = prev || next
      }

      tabs.value.splice(index, 1)
      cb?.(targetTab)
    }

    const delOther = (path: string, cb?: () => void) => {
      tabs.value = tabs.value.filter(t => t.path === path || t.meta?.lock)
      cb?.()
    }

    const delLeft = (path: string, cb?: () => void) => {
      const index = tabs.value.findIndex(t => t.path === path)
      if (index <= 0) {
        return
      }

      nextTick(() => {
        tabs.value = [...tabs.value.slice(0, index).filter(t => t.meta?.lock), ...tabs.value.slice(index)]
        cb?.()
      })
    }

    const delRight = (path: string, cb?: () => void) => {
      const index = tabs.value.findIndex(t => t.path === path)
      if (index === -1 || index === tabs.value.length - 1) {
        return
      }
      nextTick(() => {
        tabs.value = [...tabs.value.slice(0, index + 1), ...tabs.value.slice(index + 1).filter(t => t.meta?.lock)]
        cb?.()
      })
    }

    const lockTab = (path: string) => {
      const index = tabs.value.findIndex(t => t.path === path)
      if (index !== -1 && tabs.value[index]) {
        if (!tabs.value[index].meta) {
          tabs.value[index].meta = {}
        }
        tabs.value[index].meta.lock = !tabs.value[index].meta.lock
      }
    }

    const changeTab = (path: string, cb?: (item: IMenu) => void) => {
      const info = tabs.value.find(t => t.path === path)
      if (info) {
        if (current.value && current.value !== path) {
          previousTab.value = tabs.value.find(t => t.path === current.value)
        }
        current.value = path
        cb?.(info)
      }
    }

    const clearTab = () => {
      current.value = undefined
      previousTab.value = undefined
      tabs.value = []
    }

    return {
      current,
      tabs,
      isTab,
      addTab,
      delTab,
      changeTab,
      delOther,
      delLeft,
      delRight,
      lockTab,
      clearTab,
    }
  })
}



---
File: /packages/core/src/stores/theme.ts
---

import type { Ref } from 'vue'
import type { ThemeColorName, ThemeColorType } from '../hooks'
import { defineStore } from 'pinia'
import { inject, ref } from 'vue'
import { useManageStore } from './manage'

export interface ThemeStoreState {
  mode: Ref<'light' | 'dark' | 'auto'>
  theme: Ref<ThemeState>
  cssInit: Ref<boolean>
  setMode: (newMode: 'light' | 'dark' | 'auto') => void
  setCssInit: () => void
  setThemeColor: (type: ThemeColorType, colorName: ThemeColorName) => void
  setThemeColors: (colors: Partial<ThemeState>) => void
  resetTheme: () => void
  getTheme: () => ThemeState
}

export interface ThemeState {
  primary: ThemeColorName
  info: ThemeColorName
  success: ThemeColorName
  warning: ThemeColorName
  error: ThemeColorName
  gray: ThemeColorName
}

const defaultTheme: ThemeState = {
  primary: 'emerald',
  info: 'cyan',
  success: 'green',
  warning: 'amber',
  error: 'red',
  gray: 'zinc',
}

export function useThemeStore(manageName?: string) {
  const manage = inject<Ref<string>>('dux.manage')
  if (!manageName) {
    manageName = manage?.value || ''
  }

  if (!manageName) {
    throw new Error('manage not found')
  }

  const themeStore = createThemeStore(manageName)
  return themeStore()
}

function createThemeStore(manageName: string) {
  return defineStore<string, ThemeStoreState>(`theme-${manageName}`, () => {
    const manage = useManageStore(manageName)

    const theme = ref<ThemeState>(manage.config?.theme?.defaultTheme || defaultTheme)

    // 主题模式存储
    const mode = ref<'light' | 'dark' | 'auto'>('auto')

    // CSS初始化状态标志
    const cssInit = ref(false)

    // 标记CSS已初始化
    function setCssInit() {
      cssInit.value = true
    }

    // 设置主题模式
    function setMode(newMode: 'light' | 'dark' | 'auto') {
      mode.value = newMode
    }

    // 设置单个颜色类型
    function setThemeColor(type: ThemeColorType, colorName: ThemeColorName) {
      theme.value[type] = colorName
    }

    // 批量设置颜色
    function setThemeColors(colors: Partial<ThemeState>) {
      Object.assign(theme.value, colors)
    }

    // 重置为默认主题
    function resetTheme() {
      theme.value = { ...defaultTheme }
    }

    // 获取当前主题
    function getTheme() {
      return theme.value
    }

    return {
      mode,
      setMode,
      theme,
      cssInit,
      setCssInit,
      setThemeColor,
      setThemeColors,
      resetTheme,
      getTheme,
    }
  }, {
    persist: {
      pick: ['theme', 'mode'],
    },
  })
}



---
File: /packages/core/src/types/auth.ts
---

import type { IManageHook } from '../hooks'
import type { IUserState } from '../stores/auth'
import type { IDataProviderError } from './data'

/**
 * 认证提供者
 * 为全局或管理端提供自定义认证服务
 */
export interface IAuthProvider {

  login: (params: any, manage: IManageHook) => Promise<IAuthLoginResponse>
  logout: (params?: any, manage?: IManageHook) => Promise<IAuthLogoutResponse>

  register?: (params: any, manage?: IManageHook) => Promise<IAuthLoginResponse>
  forgotPassword?: (params: any, manage?: IManageHook) => Promise<IAuthActionResponse>
  updatePassword?: (params: any, manage?: IManageHook) => Promise<IAuthActionResponse>

  check?: (params?: any, manage?: IManageHook, auth?: IUserState) => Promise<IAuthCheckResponse>
  can?: (name: string, params?: any, manage?: IManageHook, auth?: IUserState) => boolean

  onError: (error?: IDataProviderError) => Promise<IAuthErrorResponse>
}

export interface IAuthActionResponse {
  success: boolean
  message?: string
  redirectTo?: string
  [key: string]: unknown
}

export interface IAuthLoginResponse extends IAuthActionResponse {
  data?: IUserState
}

export interface IAuthCheckResponse extends IAuthActionResponse {
  data?: IUserState
  logout?: boolean
}

export interface IAuthLogoutResponse extends IAuthActionResponse {
  logout?: boolean
}

export interface IAuthErrorResponse {
  logout?: boolean
  redirectTo?: string
  error?: IDataProviderError
}



---
File: /packages/core/src/types/config.ts
---

import type { Component } from 'vue'
import type { Options } from 'vue3-sfc-loader'
import type { RouteComponent, RouteRecordRaw } from 'vue-router'
import type { IJsonAdaptor } from '../hooks'
import type { IAuthProvider } from './auth'
import type { IDataProvider } from './data'
import type { I18nProvider } from './i18n'
import type { IManage } from './manage'
import type { IConfigTheme } from './theme'

/**
 * 全局配置
 */
export interface IConfig {
  // 标题
  title?: string
  // 版权
  copyright?: string
  // 描述
  description?: string
  // 默认语言
  lang?: string
  // 扩展配置
  extends?: Record<string, any>
  // 默认管理端
  defaultManage?: string
  // 管理端提供者
  manages: IManage[]
  // 全局认证提供者
  authProvider?: IAuthProvider
  // 全局数据提供者
  dataProvider?: IDataProvider | Record<string, IDataProvider>
  // 全局国际化提供者
  i18nProvider?: I18nProvider
  // 全局布局配置
  components?: IConfigComponent
  // 全局路由配置
  routes?: RouteRecordRaw[]
  // 全局主题
  theme?: IConfigTheme

  // 全局包配置
  remote?: {
    packages?: Options
    apiMethod?: string
    apiRoutePath?: string | ((path: string) => string)
  }

  // 全局 JSON Schema 配置
  jsonSchema?: {
    adaptors?: IJsonAdaptor[]
    components?: Record<string, Component> | Component[]
  }

  [key: string]: any
}

export interface IConfigComponent {
  authLayout?: RouteComponent // 认证布局
  noAuthLayout?: RouteComponent // 未认证布局

  notFound?: RouteComponent // 未找到布局
  notAuthorized?: RouteComponent // 未授权布局
  error?: RouteComponent // 错误布局
  exception?: RouteComponent // 异常布局

  iframe?: RouteComponent // iframe 组件
  remote?: RouteComponent // remote 组件
}



---
File: /packages/core/src/types/data.ts
---

import type { IManageHook } from '../hooks'
import type { IUserState } from '../stores'

/**
 * 数据提供者
 * 为全局或管理端提供自定义数据源处理服务
 */
export interface IDataProvider {

  // 获取接口地址
  apiUrl?: (path?: string, basePath?: string) => string

  // 获取列表
  getList: (options: IDataProviderListOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 创建数据
  create: (options: IDataProviderCreateOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 更新数据
  update: (options: IDataProviderUpdateOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 删除单个数据
  deleteOne: (options: IDataProviderDeleteOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 获取单个数据
  getOne: (options: IDataProviderGetOneOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 获取多个数据
  getMany: (options: IDataProviderGetManyOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 创建多个数据
  createMany: (options: IDataProviderCreateManyOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 更新多个数据
  updateMany: (options: IDataProviderUpdateManyOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 删除多个数据
  deleteMany: (options: IDataProviderDeleteManyOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 自定义请求
  custom: (options: IDataProviderCustomOptions, manage?: IManageHook, auth?: IUserState) => Promise<IDataProviderResponse>
  // 获取数据总数
  getTotal: (options: IDataProviderResponse) => number
}

export interface IDataProviderResponse {
  message?: string
  data?: any
  meta?: Record<string, any>
  raw?: any
  [key: string]: any
}

export interface IDataProviderError {
  status?: number
  message?: string
  data?: any
  meta?: Record<string, any>
  raw?: any
  [key: string]: any
}

export interface IDataProviderPagination {
  page?: number
  pageSize?: number
  pageCount?: number
  total?: number
}

export interface IDataProviderListOptions {
  path: string
  pagination?: IDataProviderPagination | boolean
  sorters?: Record<string, 'asc' | 'desc'>
  filters?: Record<string, any>
  meta?: Record<string, any>
}

export interface IDataProviderCreateOptions {
  path?: string
  data?: any
  meta?: Record<string, any>
}

export interface IDataProviderUpdateOptions extends IDataProviderCreateOptions {
  id?: string | number
}

export interface IDataProviderGetOneOptions {
  path: string
  id?: string | number
  meta?: Record<string, any>
}

export interface IDataProviderGetManyOptions {
  path: string
  ids: string[] | number[]
  meta?: Record<string, any>
}

export interface IDataProviderCreateManyOptions {
  path?: string
  data?: any[]
  meta?: Record<string, any>
}

export interface IDataProviderUpdateManyOptions {
  path?: string
  data?: any
  meta?: Record<string, any>
  ids: string[] | number[]
}

export interface IDataProviderDeleteManyOptions {
  path?: string
  meta?: Record<string, any>
  ids: string[] | number[]
}

export interface IDataProviderDeleteOptions {
  path?: string
  meta?: Record<string, any>
  id?: string | number
}

export interface IDataProviderProgress {
  loaded: number
  total?: number
  percent?: number
}

export interface IDataProviderCustomOptions {
  path?: string
  method?: string
  sorters?: Record<string, 'asc' | 'desc'>
  filters?: Record<string, any>
  query?: Record<string, any>
  headers?: Record<string, string>
  meta?: Record<string, any>
  payload?: any
  signal?: AbortSignal
  onUploadProgress?: (progress: IDataProviderProgress) => void
  onDownloadProgress?: (progress: IDataProviderProgress) => void
}



---
File: /packages/core/src/types/i18n.ts
---

/**
 * 国际化提供者
 * 为全局或管理端提供自定义国际化服务
 */
export interface I18nProvider {
  t: (key: string, options?: any, defaultMessage?: string) => string
  changeLocale: (lang: string, options?: any) => Promise<any>
  loadLocale: (lang: string, files: Record<string, unknown>) => Promise<any>
  mergeLocale: (lang: string, messages: Record<string, unknown>) => void
  getLocale: () => string
  getLocales: () => string[]
}



---
File: /packages/core/src/types/index.ts
---

export * from './config'
export * from './manage'
export * from './theme'
export * from './auth'
export * from './data'
export * from './menu'
export * from './i18n'



---
File: /packages/core/src/types/manage.ts
---

import type { Component } from 'vue'
import type { Options } from 'vue3-sfc-loader'
import type { RouteRecordRaw } from 'vue-router'
import type { IJsonAdaptor } from '../hooks'
import type { IAuthProvider } from './auth'
import type { IConfigComponent } from './config'
import type { IDataProvider } from './data'
import type { I18nProvider } from './i18n'
import type { IMenu } from './menu'
import type { IConfigTheme } from './theme'

/**
 * 管理配置
 * 为管理端提供自定义管理服务
 */
export interface IManage {
  name: string // 名称、唯一标识

  title: string // 标题
  copyright?: string // 版权
  description?: string // 描述

  register?: boolean // 注册
  forgotPassword?: boolean // 忘记密码
  updatePassword?: boolean // 更新密码

  apiRoutePath?: string // 接口路由地址

  authProvider?: IAuthProvider // 认证提供者
  dataProvider?: IDataProvider | Record<string, IDataProvider> // 数据提供者
  i18nProvider?: I18nProvider // 国际化提供者

  routePrefix?: string // 路由前缀
  routes?: RouteRecordRaw[] // 路由配置
  menus?: IMenu[] // 菜单配置

  components?: IConfigComponent // 组件配置

  theme?: IConfigTheme // 主题覆盖

  apiBasePath?: string // 接口基础路径

  // 全局包配置
  remote?: {
    packages?: Options
    apiMethod?: string
    apiRoutePath?: string | ((path: string) => string)
  }

  // 全局 JSON Schema 配置
  jsonSchema?: {
    adaptors?: IJsonAdaptor[]
    components?: Record<string, Component> | Component[]
  }

  [key: string]: any
}



---
File: /packages/core/src/types/menu.ts
---

import type { RouteComponent } from 'vue-router'

export interface IMenu {
  // 菜单名称
  label?: string
  // 菜单唯一标识
  name: string
  // 菜单路径
  path?: string
  // 菜单图标
  icon?: string
  // 菜单排序
  sort?: number
  // 父级菜单
  parent?: string
  // 是否隐藏
  hidden?: boolean
  // 菜单加载器 ('iframe' | 'link' | 'component')
  loader?: string
  // 菜单组件
  component?: RouteComponent
  // 菜单元数据 (当 loader 为 'link' 时，可在 meta.url 中设置外部链接地址)
  meta?: Record<string, any>
}



---
File: /packages/core/src/types/theme.ts
---

import type { ThemeConfig } from '../hooks'
import type { ThemeState } from '../stores'

// 主题配置
export interface IConfigTheme {
  logo?: string
  darkLogo?: string
  banner?: string
  darkBanner?: string
  config?: ThemeConfig
  defaultTheme?: ThemeState
}

export interface ITheme {
  logo?: string
  banner?: string
}



---
File: /packages/core/src/utils/bus.ts
---

import mitt from 'mitt'

export const emitter = mitt()



---
File: /packages/core/src/utils/index.ts
---

export * from './bus'
export * from './theme'
export * from './tree'



---
File: /packages/core/src/utils/theme.ts
---

function withRgb(variableName: string) {
  return `rgb(var(${variableName}))`
}

function withOpacity(variableName: string, opacityVar: string) {
  return `color-mix(in oklab, rgb(var(${variableName})) var(${opacityVar}, 100%), transparent)`
}

export function themePreset(themeColor: Record<string, any>) {
  // 常量定义
  const SHADES = ['50', '100', '200', '300', '400', '500', '600', '700', '800', '900', '950']
  const COLOR_TYPES = ['primary', 'info', 'success', 'warning', 'error', 'gray']
  const SCENES = ['hover', 'pressed', 'focus', 'disabled']

  // 构建颜色变量映射
  const colorsVar: Record<string, Record<string, any>> = {
    white: { DEFAULT: withRgb('--ui-color-white') },
    black: { DEFAULT: withRgb('--ui-color-black') },
  }

  // 生成基础色彩变量
  Object.keys(themeColor).forEach((colorName) => {
    colorsVar[colorName] = {}
    SHADES.forEach((shade) => {
      colorsVar[colorName][shade] = withRgb(`--base-color-${colorName}-${shade}`)
    })
  })

  // 生成 UI 色彩变量
  COLOR_TYPES.forEach((type) => {
    colorsVar[type] = {
      DEFAULT: withOpacity(`--ui-color-${type}`, '--un-text-opacity'),
    }

    SHADES.forEach((shade) => {
      colorsVar[type][shade] = withOpacity(`--ui-color-${type}-${shade}`, '--un-text-opacity')
    })

    SCENES.forEach((scene) => {
      colorsVar[type][scene] = withOpacity(`--ui-color-${type}-${scene}`, '--un-text-opacity')
    })
  })

  // 语义化颜色定义
  const semanticColors = {
    text: ['default', 'dimmed', 'muted', 'toned', 'highlighted', 'inverted'],
    bg: ['default', 'muted', 'elevated', 'accented', 'inverted'],
    border: ['default', 'muted', 'accented', 'inverted'],
  }

  function createSemanticColorRules(prefix: string, property: string, variants: string[], opacityVar: string, sourcePrefix?: string) {
    const rules: any[] = []

    variants.forEach((variant) => {
      const cssVarPrefix = sourcePrefix || prefix
      const cssVar = `--ui-${cssVarPrefix}${variant === 'default' ? '' : `-${variant}`}`

      rules.push([
        `${prefix}-${variant}`,
        {
          [property]: `color-mix(in oklab, rgb(var(${cssVar})) var(${opacityVar}, 100%), transparent)`,
          [opacityVar]: '100%',
        },
      ])

      rules.push([
        new RegExp(`^${prefix}-${variant}\\/(\\d*\\.?\\d+)(%?)$`),
        ([, opacity, isPercent]: string[]) => {
          const opacityValue = Number(opacity)
          let opacityStr: string
          if (isPercent || opacityValue > 1) {
            opacityStr = `${opacityValue}%`
          }
          else {
            // 小数转百分比
            opacityStr = `${opacityValue * 100}%`
          }
          return {
            [property]: `color-mix(in oklab, rgb(var(${cssVar})) var(${opacityVar}, 100%), transparent)`,
            [opacityVar]: opacityStr,
          }
        },
      ])

      rules.push([
        new RegExp(`^${prefix}-${variant}\\[(.+)\\]$`),
        ([, value]: string[]) => ({
          [property]: value.replace(/_/g, ' '),
        }),
      ])
    })

    return rules
  }

  // 生成所有语义化颜色规则
  const textRules = createSemanticColorRules('text', 'color', semanticColors.text, '--un-text-opacity')
  const bgRules = createSemanticColorRules('bg', 'background-color', semanticColors.bg, '--un-bg-opacity')
  const borderRules = createSemanticColorRules('border', 'border-color', semanticColors.border, '--un-border-opacity')
  const ringRules = createSemanticColorRules('ring', '--un-ring-color', semanticColors.border, '--un-ring-opacity', 'border')

  const divideRules: any[] = []
  semanticColors.border.forEach((variant) => {
    const cssVar = `--ui-border${variant === 'default' ? '' : `-${variant}`}`

    divideRules.push([
      new RegExp(`^divide-${variant}$`),
      (_: any, { rawSelector }: any) => {
        const selector = rawSelector.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        return `
          .${selector} > :not(:last-child) {
            border-color: color-mix(in oklab, rgb(var(${cssVar})) var(--un-border-opacity, 100%), transparent);
            --un-border-opacity: 100%;
          }`
      },
    ])

    divideRules.push([
      new RegExp(`^divide-${variant}\\/(\\d*\\.?\\d+)(%?)$`),
      ([, opacity, isPercent]: string[], { rawSelector }: any) => {
        const opacityValue = Number(opacity)
        let opacityStr: string
        if (isPercent || opacityValue > 1) {
          opacityStr = `${opacityValue}%`
        }
        else {
          opacityStr = `${opacityValue * 100}%`
        }
        const selector = rawSelector.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
        return `
          .${selector} > :not(:last-child) {
            border-color: color-mix(in oklab, rgb(var(${cssVar})) var(--un-border-opacity, 100%), transparent);
            --un-border-opacity: ${opacityStr};
          }`
      },
    ])
  })

  const rules = [
    ...textRules,
    ...bgRules,
    ...borderRules,
    ...ringRules,
    ...divideRules,
  ]

  return {
    name: 'preset-theme',
    theme: {
      colors: colorsVar,
    },
    rules,
  }
}



---
File: /packages/core/src/utils/tree.ts
---

interface TreeNode {
  [key: string]: any
}

interface TreeOptions {
  idKey: string
  parentKey: string
  sortKey: string
  childrenKey: string
}

export function arrayToTree(data: Record<string, any>[], options: TreeOptions, key?: any): TreeNode[] {
  let itemArr: TreeNode[] = []
  data.forEach((item) => {
    if (item[options.parentKey] === key) {
      const children = arrayToTree(data, options, item[options.idKey])

      if (children.length > 0) {
        item[options.childrenKey] = children
      }
      itemArr.push(item)
    }
  })
  itemArr = itemArr.sort((a, b) => {
    return a[options.sortKey] - b[options.sortKey]
  })
  return itemArr
}

export function searchTree(tree: TreeNode[], func: (item: TreeNode) => boolean, findArr: TreeNode[] = []) {
  if (!tree || !tree.length) {
    return []
  }
  for (const data of tree) {
    findArr.push(data)
    if (func(data)) {
      return findArr
    }
    if (data?.children && data?.children?.length) {
      const findChildren = searchTree(data.children, func, findArr)
      if (findChildren.length)
        return findChildren
    }
    findArr.pop()
  }
  return []
}

export function treeToArr<T>(tree: TreeNode[], idKey: string | number, childrenKey: string): T[] {
  let arr: any[] = []
  if (!tree || !tree.length) {
    return arr
  }
  for (const data of tree) {
    arr.push(data[idKey])
    if (data[childrenKey] && data[childrenKey].length) {
      const findChildren = treeToArr(data[childrenKey], idKey, childrenKey)
      if (findChildren.length)
        arr = arr.concat(findChildren)
    }
  }
  return arr
}



---
File: /packages/core/src/index.ts
---

export * from './components'
export * from './config'
export * from './hooks'
export * from './main'
export * from './preset'
export * from './provider'
export * from './router'
export * from './stores'
export * from './types'
export * from './utils'



---
File: /packages/core/src/main.ts
---

import type { App } from 'vue'
import type { IConfig } from './types'
import { VueQueryPlugin } from '@tanstack/vue-query'
import { createPinia } from 'pinia'
import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'
import { ref } from 'vue'
import { permissionDirective } from './directive'
import { initFormValidate } from './hooks'
import { initRouter } from './router/route'

export function createDux(config: IConfig) {
  const pinia = createPinia()
  pinia.use(piniaPluginPersistedstate)

  return {
    install(app: App) {
      // eslint-disable-next-line no-console
      console.log(
        `%c dux-vue %c dux.cn %c`,
        'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',
        'background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',
        'background:transparent',
      )

      initFormValidate()

      const manageRef = ref<string>()
      app.provide('dux.config', config)
      app.provide('dux.manage', manageRef)
      app.directive('can', permissionDirective)
      app.use(pinia)
      app.use(VueQueryPlugin)
      app.use(initRouter(config))
    },
  }
}



---
File: /packages/core/.gitignore
---

# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# Dependencies
node_modules
.pnp
.pnp.js

# Local env files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# Testing
coverage

# Turbo
.turbo

# Vercel
.vercel

# Build Outputs
.next/
out/
build
dist


# Debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Misc
.DS_Store
*.pem



---
File: /packages/core/CHANGELOG.md
---

# @duxweb/dvha-core

## 1.0.34

## 1.0.33

### Patch Changes

- feat: 增加代码高亮组件

## 1.0.32

### Patch Changes

- fix: 修正部分显示问题

## 1.0.31

### Patch Changes

- feat: 增加文件选择器

## 1.0.30

## 1.0.29

## 1.0.28

### Patch Changes

- feat(pro): 增加表格 header 插槽

## 1.0.27

### Patch Changes

- feat: 修正部分设计器问题

## 1.0.26

### Patch Changes

- feat: 增加表单设计器组件

## 1.0.25

### Patch Changes

- feat(pro): 增加图像编辑器

## 1.0.24

## 1.0.23

## 1.0.22

## 1.0.21

### Patch Changes

- chore(pro): 修正设置面板样式配置
  feat(pro): 增加手册检测登录和定时检测
  feat(core): 增加上传请求附加参数
  feat(pro): 增加文件管理器上传参数

## 1.0.20

### Patch Changes

- fix: 数据导入修正数据
  fix(pro): 修正用户头像昵称
  chore(core): 默认不限制导出页面数
  chore(core): 默认关闭数据导入

## 1.0.19

### Patch Changes

- feat(pro): 增加上传驱动全局配置
  feat(pro): 修改表单页面组件为居中布局
  feat(pro): 增加图标选择器
  feat(pro): 增加空列表状态页
  feat(pro): 增加空页面状态
  feat(pro): 增加列表筛选组件布局
  deat(pro): 增加侧栏面板的页面样式
  fix(pro): 修正dvha pro popover 背景透明度
  fix(pro): 修改筛选器为 modal 弹窗
  fix(core): 修正无限列表与普通列表的 key

## 1.0.18

### Patch Changes

- feat: 增加树形筛选,增加图标组件

## 1.0.17

### Patch Changes

- chore: 修正部分参数问题

## 1.0.16

### Patch Changes

- feat: 增加 data 的 apiBasePath 参数

## 1.0.15

### Patch Changes

- feat: 增加 Json 渲染器组件全局配置
  chore: 优化部分组件加载模式
  chore: 统一部分组件接口命名

## 1.0.14

### Patch Changes

- feat: 更换组件的内容为语言包
  fix: 修正部分适配 pro 版的问题

## 0.1.23

### Patch Changes

- fix: 修正树形与选择器请求问题
  feat: 增加数据提供者获取总量接口方法

## 0.1.22

### Patch Changes

- feat: 增加pro版本示例
  fix: 修正部分细节问题
  chore: 更换工具链为 PNPM

## 0.1.21

### Patch Changes

- fix: 修正部分功能错误
  feat: 增加增强表单功能

## 0.1.20

### Patch Changes

- - fix: 修正useData 提交重置数据
    chore: 优化弹出层的无障碍访问,优化 i18n 的异常隐藏

## 0.1.19

### Patch Changes

- feat: 增加 JSON 渲染器 hook

## 0.1.18

### Patch Changes

- feat(theme): 增加手动主题切换
  chore(data): 优化数据获取抖动
  feat(export): 增加导出进度监听,增加 maxPage 回调配置
  feat(naiveui): 增加表格增强 hook

## 0.1.17

### Patch Changes

- fix: 修正主题变量针对 tailwind 的透明度处理

## 0.1.16

### Patch Changes

- feat: 增加主题管理器的全局色彩管理

## 0.1.15

### Patch Changes

- feat: 增加 useTree 异步树形 hook

## 0.1.14

### Patch Changes

- fix: useUpload 单文件上传限制

## 0.1.13

### Patch Changes

- feat: 增加上传功能

## 0.1.12

### Patch Changes

- feat: 增加 csv 导入导出 cook

## 0.1.11

### Patch Changes

- feat: 增加导入 hook

## 0.1.10

### Patch Changes

- feat: 增加导出 hook,修正无限滚动分页 bug

## 0.1.9

### Patch Changes

- change: 更换许可协议为 MIT

## 0.1.8

### Patch Changes

- feet: 增加 useForm 功能,优化 useSelect

## 0.1.7

### Patch Changes

- chore: 优化异步选择器的防抖等功能

## 0.1.6

### Patch Changes

- fix: 修正路由刷新重定向,修正 query-vue 引入

## 0.1.5

### Patch Changes

- fix: 修正空权限验证

## 0.1.4

### Patch Changes

- 增加默认状态页面放置告警

## 0.1.3

### Patch Changes

- chore: 增加认证提供者的权限配置与相关 hook

## 0.1.2

### Patch Changes

- feat: 增加国家化相关接口

## 0.1.1

### Patch Changes

- fix: 修正简单授权的方法获取

## 0.1.0

### Minor Changes

- 增加默认授权 API 路径

## 0.0.9

### Patch Changes

- 增加多数据源配置,移除全局 ApiUrl 等参数

## 0.0.8

### Patch Changes

- fix: 修正编译脚本

## 0.0.7

### Patch Changes

- chore: 更新依赖和编译

## 0.0.6

### Patch Changes

- fix: dependencie @tanstack/vue-query

## 0.0.5

### Patch Changes

- 增加 loader 加载器类型

## 0.0.4

### Patch Changes

- update base releases

## 0.0.3

### Patch Changes

- fix: 更新内部依赖

## 0.0.2

### Patch Changes

- init



---
File: /packages/core/LICENSE
---

                   GNU LESSER GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.


  This version of the GNU Lesser General Public License incorporates
the terms and conditions of version 3 of the GNU General Public
License, supplemented by the additional permissions listed below.

  0. Additional Definitions.

  As used herein, "this License" refers to version 3 of the GNU Lesser
General Public License, and the "GNU GPL" refers to version 3 of the GNU
General Public License.

  "The Library" refers to a covered work governed by this License,
other than an Application or a Combined Work as defined below.

  An "Application" is any work that makes use of an interface provided
by the Library, but which is not otherwise based on the Library.
Defining a subclass of a class defined by the Library is deemed a mode
of using an interface provided by the Library.

  A "Combined Work" is a work produced by combining or linking an
Application with the Library.  The particular version of the Library
with which the Combined Work was made is also called the "Linked
Version".

  The "Minimal Corresponding Source" for a Combined Work means the
Corresponding Source for the Combined Work, excluding any source code
for portions of the Combined Work that, considered in isolation, are
based on the Application, and not on the Linked Version.

  The "Corresponding Application Code" for a Combined Work means the
object code and/or source code for the Application, including any data
and utility programs needed for reproducing the Combined Work from the
Application, but excluding the System Libraries of the Combined Work.

  1. Exception to Section 3 of the GNU GPL.

  You may convey a covered work under sections 3 and 4 of this License
without being bound by section 3 of the GNU GPL.

  2. Conveying Modified Versions.

  If you modify a copy of the Library, and, in your modifications, a
facility refers to a function or data to be supplied by an Application
that uses the facility (other than as an argument passed when the
facility is invoked), then you may convey a copy of the modified
version:

   a) under this License, provided that you make a good faith effort to
   ensure that, in the event an Application does not supply the
   function or data, the facility still operates, and performs
   whatever part of its purpose remains meaningful, or

   b) under the GNU GPL, with none of the additional permissions of
   this License applicable to that copy.

  3. Object Code Incorporating Material from Library Header Files.

  The object code form of an Application may incorporate material from
a header file that is part of the Library.  You may convey such object
code under terms of your choice, provided that, if the incorporated
material is not limited to numerical parameters, data structure
layouts and accessors, or small macros, inline functions and templates
(ten or fewer lines in length), you do both of the following:

   a) Give prominent notice with each copy of the object code that the
   Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the object code with a copy of the GNU GPL and this license
   document.

  4. Combined Works.

  You may convey a Combined Work under terms of your choice that,
taken together, effectively do not restrict modification of the
portions of the Library contained in the Combined Work and reverse
engineering for debugging such modifications, if you also do each of
the following:

   a) Give prominent notice with each copy of the Combined Work that
   the Library is used in it and that the Library and its use are
   covered by this License.

   b) Accompany the Combined Work with a copy of the GNU GPL and this license
   document.

   c) For a Combined Work that displays copyright notices during
   execution, include the copyright notice for the Library among
   these notices, as well as a reference directing the user to the
   copies of the GNU GPL and this license document.

   d) Do one of the following:

       0) Convey the Minimal Corresponding Source under the terms of this
       License, and the Corresponding Application Code in a form
       suitable for, and under terms that permit, the user to
       recombine or relink the Application with a modified version of
       the Linked Version to produce a modified Combined Work, in the
       manner specified by section 6 of the GNU GPL for conveying
       Corresponding Source.

       1) Use a suitable shared library mechanism for linking with the
       Library.  A suitable mechanism is one that (a) uses at run time
       a copy of the Library already present on the user's computer
       system, and (b) will operate properly with a modified version
       of the Library that is interface-compatible with the Linked
       Version.

   e) Provide Installation Information, but only if you would otherwise
   be required to provide such information under section 6 of the
   GNU GPL, and only to the extent that such information is
   necessary to install and execute a modified version of the
   Combined Work produced by recombining or relinking the
   Application with a modified version of the Linked Version. (If
   you use option 4d0, the Installation Information must accompany
   the Minimal Corresponding Source and Corresponding Application
   Code. If you use option 4d1, you must provide the Installation
   Information in the manner specified by section 6 of the GNU GPL
   for conveying Corresponding Source.)

  5. Combined Libraries.

  You may place library facilities that are a work based on the
Library side by side in a single library together with other library
facilities that are not Applications and are not covered by this
License, and convey such a combined library under terms of your
choice, if you do both of the following:

   a) Accompany the combined library with a copy of the same work based
   on the Library, uncombined with any other library facilities,
   conveyed under the terms of this License.

   b) Give prominent notice with the combined library that part of it
   is a work based on the Library, and explaining where to find the
   accompanying uncombined form of the same work.

  6. Revised Versions of the GNU Lesser General Public License.

  The Free Software Foundation may publish revised and/or new versions
of the GNU Lesser General Public License from time to time. Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

  Each version is given a distinguishing version number. If the
Library as you received it specifies that a certain numbered version
of the GNU Lesser General Public License "or any later version"
applies to it, you have the option of following the terms and
conditions either of that published version or of any later version
published by the Free Software Foundation. If the Library as you
received it does not specify a version number of the GNU Lesser
General Public License, you may choose any version of the GNU Lesser
General Public License ever published by the Free Software Foundation.

  If the Library as you received it specifies that a proxy can decide
whether future versions of the GNU Lesser General Public License shall
apply, that proxy's public statement of acceptance of any version is
permanent authorization for you to choose that version for the
Library.


---
File: /packages/core/package.json
---

{
  "name": "@duxweb/dvha-core",
  "type": "module",
  "version": "1.0.34",
  "author": "DuxWeb",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/duxweb/dvha.git"
  },
  "exports": {
    ".": {
      "dvha:development": {
        "types": "./src/index.ts",
        "import": "./src/index.ts"
      },
      "types": "./dist/types/index.d.ts",
      "import": "./dist/esm/index.js",
      "require": "./dist/cjs/index.cjs"
    }
  },
  "main": "dist/cjs/index.cjs",
  "module": "dist/esm/index.js",
  "types": "dist/types/index.d.ts",
  "files": [
    "LICENSE",
    "README.md",
    "dist"
  ],
  "scripts": {
    "clean": "rimraf dist",
    "build": "pnpm run clean && vue-tsc --noEmit && vite build && pnpm run build:types",
    "build:types": "vue-tsc --declaration --emitDeclarationOnly --outDir dist/types",
    "lint": "eslint .",
    "lint:fix": "eslint . --fix"
  },
  "dependencies": {
    "@overlastic/vue": "^0.8.1",
    "@tanstack/vue-query": "^5.80.7",
    "@vee-validate/rules": "^4.15.1",
    "@vueuse/core": "^13.3.0",
    "@vueuse/integrations": "^13.3.0",
    "axios": "^1.9.0",
    "clsx": "^2.1.1",
    "colorizr": "^3.0.8",
    "crypto-js": "^4.2.0",
    "dayjs": "^1.11.13",
    "jsep": "^1.4.0",
    "json-2-csv": "^5.5.9",
    "lodash-es": "^4.17.21",
    "mathjs": "^14.5.2",
    "mime": "^4.0.7",
    "mitt": "^3.0.1",
    "pinia": "^3.0.3",
    "pinia-plugin-persistedstate": "^4.3.0",
    "tslib": "^2.8.1",
    "vee-validate": "^4.15.1",
    "vue": "^3.5.0",
    "vue-i18n": "^11.1.6",
    "vue-router": "^4.5.1",
    "vue3-sfc-loader": "^0.9.5"
  },
  "devDependencies": {
    "rimraf": "^6.0.1",
    "vue-tsc": "^2.2.10"
  }
}



---
File: /packages/core/README.md
---




---
File: /packages/core/tsconfig.json
---

{
  "compilerOptions": {
    "target": "ESNext",
    "jsx": "preserve",
    "jsxImportSource": "vue",
    "lib": [
      "ESNext",
      "DOM"
    ],
    "moduleDetection": "force",
    "useDefineForClassFields": true,
    "baseUrl": ".",
    "rootDir": "src",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "allowJs": true,
    "strict": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": false,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "declaration": true,
    "importHelpers": true,
    "noEmit": false,
    "outDir": "dist",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "isolatedModules": true,
    "skipLibCheck": true
  },
  "include": [
    "src/**/*.*",
    "src/**/*.vue",
    "typings.d.ts",
    "uno.config.ts"
  ],
  "exclude": [
    "node_modules",
    "dist"
  ]
}



---
File: /packages/core/typings.d.ts
---

// typings.d.ts
declare module '*.css' {
  const content: string
  export default content
}

declare module '*?raw' {
  const content: string
  export default content
}



---
File: /packages/core/vite.config.ts
---

import { definePackageConfig } from '../../config/vite.config.build'

export default definePackageConfig(__dirname)

